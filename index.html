<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kilmer - Syntactic Tree Diagrams</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Source+Sans+3:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --color-bg: #faf9f7;
      --color-surface: #ffffff;
      --color-text: #1a1a1a;
      --color-text-muted: #6b6b6b;
      --color-accent: #1a472a;
      --color-border: #e0ddd8;
      --color-select: #2563eb; 
      --font-display: 'Crimson Pro', Georgia, serif;
      --font-body: 'Source Sans 3', system-ui, sans-serif;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: var(--font-body); background-color: var(--color-bg); color: var(--color-text); min-height: 100vh; overflow-x: hidden; }
    .container { max-width: 1300px; margin: 0 auto; padding: 40px 24px; }

    .header { text-align: center; margin-bottom: 24px; }
    .header-logo { max-width: 320px; height: auto; }
    
    .toolbar {
      background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px;
      padding: 16px 24px; margin-bottom: 32px; display: flex; gap: 10px; flex-wrap: wrap;
      align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.04); position: sticky; top: 20px; z-index: 100;
    }

    .btn {
      font-family: var(--font-body); padding: 8px 16px; border: 1px solid var(--color-border);
      border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;
      background: var(--color-surface); transition: all 0.2s;
    }
    .btn:hover:not(:disabled) { border-color: var(--color-text); transform: translateY(-1px); }
    .btn-primary { background: var(--color-accent); color: white; border-color: var(--color-accent); }
    .btn.active-mode { background: var(--color-select); color: white; border-color: var(--color-select); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-undo-redo { font-size: 18px; padding: 6px 12px; }

    .toolbar-divider {
      width: 1px;
      height: 28px;
      background: linear-gradient(to bottom, transparent 5%, #c0bdb8 20%, #c0bdb8 80%, transparent 95%);
      margin: 0 10px;
    }

    /* Build direction switch */
    .build-switch { display: flex; align-items: center; gap: 8px; padding: 0 6px; user-select: none; }
    .build-switch-label { font-size: 13px; font-weight: 700; color: var(--color-muted); }
    .build-switch-label.active { color: var(--color-text); }

    .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute; cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #d6d6d6;
      transition: .2s;
      border-radius: 999px;
      border: 1px solid var(--color-border);
    }
    .slider:before {
      position: absolute; content: "";
      height: 18px; width: 18px;
      left: 2px; top: 2px;
      background: white;
      transition: .2s;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(0,0,0,0.18);
    }
    .switch input:focus + .slider { outline: none; box-shadow: 0 0 0 3px rgba(34, 94, 219, 0.20); }
    .switch input:checked + .slider { background: var(--color-accent); }
    .switch input:checked + .slider:before { transform: translateX(20px); }
    
    .tree-canvas {
      background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px;
      min-height: 600px; padding: 80px 40px; display: flex; justify-content: center;
      position: relative; overflow: visible;
    }

    .tree-node { display: flex; flex-direction: column; align-items: center; position: relative; }
    .node-wrapper { position: relative; padding-bottom: 15px; }
    .node-wrapper.has-sublabels { padding-bottom: 8px; }
    .node-content { display: flex; flex-direction: column; align-items: center; }
    .node-label { font-family: var(--font-display); font-size: 20px; min-height: 1.5em; display: flex; align-items: center; justify-content: center; position: relative; z-index: 10; }
    
    .node-sublabels {
      font-family: var(--font-display);
      font-size: 15px;
      color: var(--color-text-muted);
      min-height: 1.2em;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 10;
      margin-top: -2px;
      gap: 4px;
    }

    .sublabel-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border: 1px solid var(--color-border);
      border-radius: 999px;
      background: rgba(255,255,255,0.96);
    }

    .sublabel-pill .node-display {
      padding: 0;
      border: 0;
      cursor: pointer;
    }
    .sublabel-pill .node-display:hover { background: transparent; }

    .pill-x {
      width: 18px;
      height: 18px;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      background: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 1;
      padding: 0;
      color: #dc2626;
    }
    .pill-x:hover {
      background: #dc2626;
      border-color: #dc2626;
      color: white;
    }
.node-display { padding: 4px 10px; border-radius: 4px; border: 2px solid transparent; cursor: pointer; }
    .node-display:hover { background: rgba(0,0,0,0.05); }
    .node-display.is-source { border-color: var(--color-select); background: rgba(37, 99, 235, 0.05); }
    .node-display.move-active { cursor: crosshair; }
    .node-display.placeholder {
      color: #888;
      border: 1px dashed #ccc;
      background: rgba(37, 99, 235, 0.04);
      padding: 4px 12px;
      border-radius: 4px;
    }

    .node-display.placeholder:hover {
      color: var(--color-accent);
    }
    
    .node-sublabels .node-display { font-size: 15px; }
    
    .node-display i { font-style: italic; }
    .node-display sub { font-size: 0.7em; vertical-align: sub; line-height: 0; }
    .node-display sup { font-size: 0.7em; vertical-align: super; line-height: 0; }
    .node-display .overline { text-decoration: overline; }
    .node-display .double-overline { 
      text-decoration: overline; 
      border-top: 1.5px solid currentColor; 
      padding-top: 2px;
    }
    .node-display s { text-decoration: line-through; }

    .node-label input, .node-sublabels input { font-family: var(--font-display); text-align: center; outline: none; border: 2px solid var(--color-accent); border-radius: 4px; width: auto; min-width: 30px; }
    .node-label input { font-size: 18px; }
    .node-sublabels input { font-size: 14px; }

    .node-actions {
      position: absolute; top: 65%; left: 50%; transform: translateX(-50%);
      display: flex; gap: 4px; opacity: 0; pointer-events: none;
      transition: opacity 0.2s; background: white; padding: 6px; border-radius: 8px;
      border: 1px solid var(--color-border); box-shadow: 0 4px 12px rgba(0,0,0,0.12); z-index: 50;
    }
    .node-content.has-sublabels .node-actions { top: 90%; }
    .node-content:hover .node-actions, .node-actions:hover, .triangle-label:hover .node-actions { opacity: 1; pointer-events: auto; }
    .triangle-label .node-actions { top: 80%; }
    .triangle-label.has-triangle-sublabels .node-actions { top: 95%; }
    /* Bottom-up build mode: place node toolbar above the node for more intuitive "add parent" actions */
    .node-content.bottomup .node-actions {
      top: 8px;
      left: 50%;
      transform: translate(-50%, -100%);
    }


    .action-btn { min-width: 32px; height: 32px; padding: 0 6px; border: 1px solid var(--color-border); border-radius: 6px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; gap: 1px; }
    .action-btn:hover { background: var(--color-accent); color: white; }
    .action-btn.danger:hover { background: #dc2626; border-color: #dc2626; color: white; }
    .action-btn.active { background: var(--color-accent); color: white; }

    .node-children { display: flex; justify-content: center; gap: 40px; padding-top: 40px; position: relative; }
    .node-wrapper.has-sublabels + .node-children { padding-top: 22px; }
    
    .triangle-container { display: flex; flex-direction: column; align-items: center; margin-top: -15px; }
    .triangle-svg { overflow: visible; margin-bottom: 5px; }
    .triangle-label { position: relative; display: flex; flex-direction: column; align-items: center; }
    .triangle-label .node-sublabels { margin-top: 2px; }

    .arrow-delete-btn { cursor: pointer; pointer-events: auto; }
    .arrow-delete-btn rect { fill: white; stroke: var(--color-border); rx: 4; }
    .arrow-delete-btn:hover rect { fill: #dc2626; stroke: #dc2626; }
    .arrow-delete-btn:hover text { fill: white; font-weight: bold; }

    /* Redesigned Instructions */
    .instructions-panel {
      margin-top: 48px;
      background: linear-gradient(135deg, #fdfcfb 0%, #f7f6f3 100%);
      border: 1px solid var(--color-border);
      border-radius: 16px;
      overflow: visible;
    }

    .instructions-header {
      background: var(--color-accent);
      color: white;
      padding: 16px 24px;
      font-family: var(--font-display);
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      width: 100%;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }

    .instructions-header:hover {
      background: #153d23;
    }

    .collapse-icon {
      font-size: 0.9rem;
      transition: transform 0.3s ease;
    }

    .collapse-icon.expanded {
      transform: rotate(90deg);
    }

    .instructions-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1px;
      background: var(--color-border);
    }

    @media (max-width: 700px) {
      .instructions-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      .container { padding: 20px 12px; }
      .header { margin-bottom: 24px; }
      .header-logo { max-width: 240px; }
      .toolbar { 
        padding: 12px 16px; 
        gap: 8px; 
        position: static; 
      }
      .btn { 
        padding: 8px 12px; 
        font-size: 13px; 
      }
      .tree-canvas { 
        min-height: 400px; 
        padding: 40px 20px; 
        overflow-x: auto;
      }
      .node-label { font-size: 16px; }
      .node-sublabels { font-size: 13px; }
      .node-children { gap: 24px; padding-top: 30px; }
      .instructions-grid {
        grid-template-columns: 1fr;
      }
      .instructions-header { padding: 12px 16px; font-size: 1.1rem; }
      .instruction-card { padding: 16px; }
    }

    .instruction-card {
      background: white;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .instruction-card h4 {
      font-family: var(--font-display);
      font-size: 1.1rem; /* Aumentado ligeramente */
      font-weight: 600;
      color: var(--color-accent);
      display: flex;
      align-items: center;
      gap: 12px; /* Más espacio entre ícono y texto */
      margin-bottom: 8px;
    }

    .instruction-card h4 .icon {
      width: 32px;  /* Antes 24px */
      height: 32px; /* Antes 24px */
      background: var(--color-accent);
      color: white;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px; /* Antes 14px */
      font-family: var(--font-body);
      flex-shrink: 0; /* Evita que el ícono se encoja */
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Un toque de relieve */
    }

    .instruction-card p {
      font-size: 14px;
      line-height: 1.6;
      color: var(--color-text-muted);
    }

    .instruction-card ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 14px;
      line-height: 1.6;
      color: var(--color-text-muted);
    }

    .instruction-card li {
      position: relative;
      padding-left: 16px;
      margin-bottom: 4px;
    }

    .instruction-card li::before {
      content: "•";
      position: absolute;
      left: 0;
      color: var(--color-accent);
      font-weight: bold;
    }

    .instruction-card li:last-child {
      margin-bottom: 0;
    }

    .instruction-card code {
      display: inline-block;
      background: #f5f4f0;
      padding: 1px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 13px;
      color: var(--color-text);
      border: 1px solid #e8e6e1;
    }

    .instruction-card .example {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .instruction-card .example .arrow {
      color: var(--color-accent);
      font-size: 12px;
    }

    .instruction-card .example .result {
      font-family: var(--font-display);
      font-size: 15px;
    }

    .instruction-card .example .result i { font-style: italic; }
    .instruction-card .example .result sub { font-size: 0.7em; vertical-align: sub; }
    .instruction-card .example .result sup { font-size: 0.7em; vertical-align: super; }
    .instruction-card .example .result .overline { text-decoration: overline; }
    .instruction-card .example .result .double-overline { text-decoration: overline; border-top: 1.5px solid currentColor; padding-top: 2px; }
    .instruction-card .example .result s { text-decoration: line-through; }

    .text-formatting-card .formatting-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .text-formatting-card .formatting-columns ul {
      margin: 0;
    }

    .text-formatting-card .combining-header {
      font-weight: 600;
      color: var(--color-text);
      margin-bottom: 4px;
      padding-left: 0;
    }

    .text-formatting-card .combining-header::before {
      content: none;
    }

    @media (max-width: 600px) {
      .text-formatting-card .formatting-columns {
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }

    .keyboard-hint {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .key {
      display: inline-block;
      background: linear-gradient(180deg, #fafafa 0%, #e8e8e8 100%);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 12px;
      font-family: var(--font-body);
      font-weight: 600;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .instruction-card li .key {
      margin-right: 2px;
    }

    .instruction-card li .key + .key {
      margin-left: 0;
    }

    /* Quita el punto verde de las listas de atajos de teclado */
    .shortcut-list li::before {
      content: none !important;
    }

    /* Ajuste adicional para que los atajos no tengan el espacio de la viñeta */
    .shortcut-list li {
    padding-left: 0 !important;
    }

    .footer {
      margin-top: 48px;
      padding: 24px 0;
      text-align: center;
      border-top: 1px solid var(--color-border);
      color: var(--color-text-muted);
      font-size: 14px;
    }
    .footer strong { color: var(--color-text); }
    .footer a { color: var(--color-accent); text-decoration: none; }
    .footer a:hover { text-decoration: underline; }
    .footer img { 
      opacity: 0.8; 
      transition: opacity 0.2s;
      display: block;
      margin: 12px auto 0;
      height: 31px; 
      width: auto;
    }
    .footer img:hover { opacity: 1; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect, useLayoutEffect } = React;

    const LOGO_URL = "kilmer_logo.png";
    const generateId = () => Math.random().toString(36).substring(2, 11);

    const formatLabel = (text) => {
      if (!text) return '';
      return text
        .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
        .replace(/\*(.*?)\*/g, '<i>$1</i>')
        .replace(/=(.*?)=/g, '<s>$1</s>')
        .replace(/##(.*?)##/g, '<span class="double-overline">$1</span>')
        .replace(/#(.*?)#/g, '<span class="overline">$1</span>')
        // Closed format first (X¨n¨ or X_i_), then open format (X¨n or X_i until space/end)
        .replace(/¨(.*?)¨/g, '<sup>$1</sup>')
        .replace(/¨(.*?)(\s|$)/g, '<sup>$1</sup>$2')
        .replace(/_(.*?)_/g, '<sub>$1</sub>')
        .replace(/_(.*?)(\s|$)/g, '<sub>$1</sub>$2');
    };

    // Helper to measure text width for dynamic triangle sizing
    const measureText = (text, font = "20px 'Crimson Pro', Georgia, serif") => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = font;
      // Strip formatting markers for measurement
      const plainText = text
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/=(.*?)=/g, '$1')
        .replace(/##(.*?)##/g, '$1')
        .replace(/#(.*?)#/g, '$1')
        .replace(/¨(.*?)¨/g, '$1')
        .replace(/¨(.*?)(\s|$)/g, '$1$2')
        .replace(/_(.*?)_/g, '$1')
        .replace(/_(.*?)(\s|$)/g, '$1$2');
      return ctx.measureText(plainText).width;
    };

    const TreeNode = ({
      node,
      isRoot,
      updateNode,
      addNode,
      addParent,
      addSublabel,
      updateSublabel,
      removeSublabel,
      addTriangleSublabel,
      updateTriangleSublabel,
      removeTriangleSublabel,
      buildMode,
      toggleTri,
      delNode,
      isMoveMode,
      isPhaseMode,
      sourceId,
      onNodeClick,
      onPhaseClick
    }) => {
      const [editLabel, setEditLabel] = useState(false);
      const [editTri, setEditTri] = useState(false);

      const [editSubIdx, setEditSubIdx] = useState(null);
      const [subEditVal, setSubEditVal] = useState('');

      const [editTriSubIdx, setEditTriSubIdx] = useState(null);
      const [triSubEditVal, setTriSubEditVal] = useState('');

      const [val, setVal] = useState(node.label);
      const [tVal, setTVal] = useState(node.triangleText || '');

      useEffect(() => {
        setVal(node.label);
        setTVal(node.triangleText || '');
        // When the underlying node changes (undo/redo/load), exit sublabel edit mode.
        setEditSubIdx(null);
        setSubEditVal('');
        setEditTriSubIdx(null);
        setTriSubEditVal('');
      }, [node.id, node.label, node.triangleText]);

      const sublabels = Array.isArray(node.sublabels) ? node.sublabels : [];
      const hasSublabels = sublabels.length > 0;
      const triangleSublabels = Array.isArray(node.triangleSublabels) ? node.triangleSublabels : [];
      const hasTriangleSublabels = triangleSublabels.length > 0;
      const isSpecialMode = isMoveMode || isPhaseMode;

      const startEditTriangleSublabel = (idx) => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          const current = triangleSublabels[idx] ?? '...';
          setTriSubEditVal(current === '...' ? '' : current);
          setEditTriSubIdx(idx);
        }
      };

      const handleLabelClick = () => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          if (val === '...') setVal('');
          setEditLabel(true);
        }
      };

      const handleTriClick = () => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          if (tVal === '...') setTVal('');
          setEditTri(true);
        }
      };

      const startEditSublabel = (idx) => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          const current = sublabels[idx] ?? '...';
          setSubEditVal(current === '...' ? '' : current);
          setEditSubIdx(idx);
        }
      };

      // Calculate dynamic triangle width based on text
      const triangleWidth = node.triangleText !== null
        ? Math.max(80, measureText(node.triangleText || '...') + 40)
        : 80;

      return (
        <div className="tree-node" data-node-id={node.id} data-has-sublabel={hasSublabels}>
          <div className={`node-wrapper ${hasSublabels ? 'has-sublabels' : ''}`}>
            <div className={`node-content ${hasSublabels ? 'has-sublabels' : ''} ${buildMode === 'bottomup' ? 'bottomup' : ''}`}>
              <div className={`node-label ${isSpecialMode ? 'move-mode' : ''}`}>
                {editLabel ? (
                  <input
                    autoFocus
                    value={val}
                    onChange={e => setVal(e.target.value)}
                    size={Math.max(val.length, 1)}
                    onBlur={() => { updateNode(node.id, { label: val || '...' }); setEditLabel(false); }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') e.currentTarget.blur();
                      if (e.key === 'Escape') { setVal(node.label); setEditLabel(false); }
                    }}
                  />
                ) : (
                  <div
                    className={`node-display ${isSpecialMode ? 'move-active' : ''} ${sourceId === node.id ? 'is-source' : ''} ${val === '...' ? 'placeholder' : ''}`}
                    onClick={handleLabelClick}
                    dangerouslySetInnerHTML={{ __html: formatLabel(val) || '...' }}
                  />
                )}
              </div>

              {hasSublabels && (
                <div className="node-sublabels">
                  {sublabels.map((s, idx) => (
                    <div className="sublabel-pill" key={`${node.id}-sub-${idx}`}>
                      {editSubIdx === idx ? (
                        <input
                          autoFocus
                          value={subEditVal}
                          onChange={e => setSubEditVal(e.target.value)}
                          size={Math.max(subEditVal.length, 1)}
                          onBlur={() => {
                            updateSublabel(node.id, idx, subEditVal || '...');
                            setEditSubIdx(null);
                            setSubEditVal('');
                          }}
                          onKeyDown={e => {
                            if (e.key === 'Enter') e.currentTarget.blur();
                            if (e.key === 'Escape') { setEditSubIdx(null); setSubEditVal(''); }
                          }}
                        />
                      ) : (
                        <div
                          className={`node-display ${s === '...' ? 'placeholder' : ''}`}
                          onClick={() => startEditSublabel(idx)}
                          dangerouslySetInnerHTML={{ __html: formatLabel(s) || '...' }}
                        />
                      )}

                      {!isSpecialMode && (
                        <button
                          className="pill-x"
                          title="Remove this secondary label"
                          onClick={(e) => { e.stopPropagation(); removeSublabel(node.id, idx); }}
                        >
                          ×
                        </button>
                      )}
                    </div>
                  ))}
                </div>
              )}

              {!isSpecialMode && (
                <div className="node-actions">
                  {(buildMode === 'bottomup' || (!node.children && !node.triangleText && !node.terminalLocked)) && (
                    <>
                      <button
                        className="action-btn"
                        onClick={() => { if (buildMode === 'bottomup') addParent(node.id, 1); else addNode(node.id, 1); }}
                        title={buildMode === 'bottomup' ? 'Add unary parent' : 'Add single daughter'}
                      >
                        │
                      </button>
                      {buildMode === 'bottomup' ? (
                        <>
                          <button
                            className="action-btn"
                            onClick={() => addParent(node.id, 2, 'right')}
                            title="Add binary parent (sibling to the left)"
                          >
                            <span style={{fontSize: '12px'}}>→</span>⑃
                          </button>
                          <button
                            className="action-btn"
                            onClick={() => addParent(node.id, 2, 'left')}
                            title="Add binary parent (sibling to the right)"
                          >
                            ⑃<span style={{fontSize: '12px'}}>←</span>
                          </button>
                        </>
                      ) : (
                        <button
                          className="action-btn"
                          onClick={() => addNode(node.id, 2)}
                          title="Add binary branch"
                        >
                          ⑃
                        </button>
                      )}
                    </>
                  )}

                  <button className="action-btn" onClick={() => toggleTri(node.id, buildMode)} title={buildMode === 'bottomup' ? 'Add triangle parent' : 'Toggle triangle'}>△</button>

                  <button
                    className={`action-btn ${hasSublabels ? 'active' : ''}`}
                    onClick={() => addSublabel(node.id)}
                    disabled={sublabels.length >= 4}
                    title={sublabels.length >= 4 ? 'Maximum: 4 secondary labels' : 'Add a secondary label (max 4). Adding a 2nd label locks the node as terminal.'}
                  >
                    +₂
                  </button>

                  <button className="action-btn danger" onClick={() => delNode(node.id)} title="Delete node or descendants">✕</button>
                </div>
              )}
            </div>
          </div>

          {node.triangleText !== null && (
            <div className="triangle-container">
              <svg className="triangle-svg" width={triangleWidth} height="50" style={{ overflow: 'visible' }}>
                <polygon points={`${triangleWidth / 2},0 0,50 ${triangleWidth},50`} fill="none" stroke="black" strokeWidth="1.2" />
              </svg>
              <div className={`node-label triangle-label ${hasTriangleSublabels ? 'has-triangle-sublabels' : ''}`}>
                {editTri ? (
                  <input
                    autoFocus
                    value={tVal}
                    onChange={e => setTVal(e.target.value)}
                    size={Math.max(tVal.length, 1)}
                    onBlur={() => { updateNode(node.id, { triangleText: tVal || '...' }); setEditTri(false); }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') e.currentTarget.blur();
                      if (e.key === 'Escape') { setTVal(node.triangleText || ''); setEditTri(false); }
                    }}
                  />
                ) : (
                  <div className={`node-display ${tVal === '...' ? 'placeholder' : ''}`} onClick={handleTriClick} dangerouslySetInnerHTML={{ __html: formatLabel(tVal) || '...' }} />
                )}

                {hasTriangleSublabels && (
                  <div className="node-sublabels">
                    {triangleSublabels.map((s, idx) => (
                      <div className="sublabel-pill" key={`${node.id}-trisub-${idx}`}>
                        {editTriSubIdx === idx ? (
                          <input
                            autoFocus
                            value={triSubEditVal}
                            onChange={e => setTriSubEditVal(e.target.value)}
                            size={Math.max(triSubEditVal.length, 1)}
                            onBlur={() => {
                              updateTriangleSublabel(node.id, idx, triSubEditVal || '...');
                              setEditTriSubIdx(null);
                              setTriSubEditVal('');
                            }}
                            onKeyDown={e => {
                              if (e.key === 'Enter') e.currentTarget.blur();
                              if (e.key === 'Escape') { setEditTriSubIdx(null); setTriSubEditVal(''); }
                            }}
                          />
                        ) : (
                          <div
                            className={`node-display ${s === '...' ? 'placeholder' : ''}`}
                            onClick={() => startEditTriangleSublabel(idx)}
                            dangerouslySetInnerHTML={{ __html: formatLabel(s) || '...' }}
                          />
                        )}

                        {!isSpecialMode && (
                          <button
                            className="pill-x"
                            title="Remove this secondary label"
                            onClick={(e) => { e.stopPropagation(); removeTriangleSublabel(node.id, idx); }}
                          >
                            ×
                          </button>
                        )}
                      </div>
                    ))}
                  </div>
                )}

                {!isSpecialMode && (
                  <div className="node-actions">
                    <button
                      className={`action-btn ${hasTriangleSublabels ? 'active' : ''}`}
                      onClick={() => addTriangleSublabel(node.id)}
                      disabled={triangleSublabels.length >= 4}
                      title={triangleSublabels.length >= 4 ? 'Maximum: 4 secondary labels' : 'Add a secondary label (max 4)'}
                    >
                      +₂
                    </button>
                    <button className="action-btn danger" onClick={() => toggleTri(node.id, 'topdown')} title="Remove triangle">✕</button>
                  </div>
                )}
              </div>
            </div>
          )}

          {node.children && (
            <div className="node-children">
              {node.children.map(c => (
                <TreeNode
                  key={c.id}
                  node={c}
                  isRoot={false}
                  {...{
                    updateNode,
                    addNode,
                    addParent,
                    addSublabel,
                    updateSublabel,
                    removeSublabel,
                    addTriangleSublabel,
                    updateTriangleSublabel,
                    removeTriangleSublabel,
                    buildMode,
                    toggleTri,
                    delNode,
                    isMoveMode,
                    isPhaseMode,
                    sourceId,
                    onNodeClick,
                    onPhaseClick
                  }}
                />
              ))}
            </div>
          )}
        </div>
      );
    };

    const KilmerApp = () => {
      // History management for undo/redo
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const isUndoRedo = useRef(false);
      
      const [tree, setTreeInternal] = useState(null);
      const [moves, setMovesInternal] = useState([]);
      const [phases, setPhasesInternal] = useState(new Set()); // Node IDs that are phase boundaries
      const [dottedLines, setDottedLinesInternal] = useState(new Set());
      const [isMoveMode, setIsMoveMode] = useState(false);
      const [isPhaseMode, setIsPhaseMode] = useState(false);
      const [buildMode, setBuildMode] = useState('topdown');
      const [sourceId, setSourceId] = useState(null);
      const [svgLines, setSvgLines] = useState(null);
      const [showInstructions, setShowInstructions] = useState(false);
      const canvasRef = useRef(null);
      const fileRef = useRef(null);

      // Create a snapshot of current state
      const createSnapshot = useCallback(() => ({
        tree: tree ? JSON.parse(JSON.stringify(tree)) : null,
        moves: JSON.parse(JSON.stringify(moves)),
        phases: Array.from(phases),
        dottedLines: Array.from(dottedLines)
      }), [tree, moves, phases, dottedLines]);

      // Restore state from snapshot
      const restoreSnapshot = useCallback((snapshot) => {
        isUndoRedo.current = true;
        setTreeInternal(snapshot.tree);
        setMovesInternal(snapshot.moves);
        setPhasesInternal(new Set(snapshot.phases || []));
        setDottedLinesInternal(new Set(snapshot.dottedLines));
        setTimeout(() => { isUndoRedo.current = false; }, 0);
      }, []);

      // Push current state to history
      const pushHistory = useCallback(() => {
        if (isUndoRedo.current) return;
        const snapshot = createSnapshot();
        setHistory(prev => {
          const newHistory = prev.slice(0, historyIndex + 1);
          newHistory.push(snapshot);
          // Limit history to 50 states
          if (newHistory.length > 50) newHistory.shift();
          return newHistory;
        });
        setHistoryIndex(prev => Math.min(prev + 1, 49));
      }, [createSnapshot, historyIndex]);

      // Wrapped setters that track history
      const setTree = useCallback((updater) => {
        setTreeInternal(prev => {
          const newVal = typeof updater === 'function' ? updater(prev) : updater;
          return newVal;
        });
      }, []);

      const setMoves = useCallback((updater) => {
        setMovesInternal(prev => {
          const newVal = typeof updater === 'function' ? updater(prev) : updater;
          return newVal;
        });
      }, []);

      const setDottedLines = useCallback((updater) => {
        setDottedLinesInternal(prev => {
          const newVal = typeof updater === 'function' ? updater(prev) : updater;
          return newVal;
        });
      }, []);

      const setPhases = useCallback((updater) => {
        setPhasesInternal(prev => {
          const newVal = typeof updater === 'function' ? updater(prev) : updater;
          return newVal;
        });
      }, []);

      // Toggle phase boundary on a node
      const togglePhase = useCallback((nodeId) => {
        setPhases(prev => {
          const newSet = new Set(prev);
          if (newSet.has(nodeId)) {
            newSet.delete(nodeId);
          } else {
            newSet.add(nodeId);
          }
          return newSet;
        });
      }, []);

      // Track changes and push to history
      useEffect(() => {
        if (!isUndoRedo.current && tree !== null) {
          const timeoutId = setTimeout(pushHistory, 100);
          return () => clearTimeout(timeoutId);
        }
      }, [tree, moves, phases, dottedLines]);

      // Undo function
      const undo = useCallback(() => {
        if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          restoreSnapshot(history[newIndex]);
        }
      }, [history, historyIndex, restoreSnapshot]);

      // Redo function
      const redo = useCallback(() => {
        if (historyIndex < history.length - 1) {
          const newIndex = historyIndex + 1;
          setHistoryIndex(newIndex);
          restoreSnapshot(history[newIndex]);
        }
      }, [history, historyIndex, restoreSnapshot]);

      const canUndo = historyIndex > 0;
      const canRedo = historyIndex < history.length - 1;

      // Save function for keyboard shortcut
      const saveTree = useCallback(() => {
        if (!tree) return;
        const filename = (prompt('Enter filename:', 'tree') || 'tree').replace(/\s+/g, '_');
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([JSON.stringify({tree, moves, phases: Array.from(phases), dottedLines: Array.from(dottedLines)})], {type:'application/json'}));
        a.download = `${filename}.kilmer`; 
        a.click();
      }, [tree, moves, phases, dottedLines]);

      // Keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Check if we're in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          
          // Ctrl+Z or Cmd+Z: Undo
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
          }
          // Ctrl+Y or Cmd+Y or Ctrl+Shift+Z: Redo
          if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey) || (e.key === 'Z' && e.shiftKey))) {
            e.preventDefault();
            redo();
          }
          // Ctrl+S or Cmd+S: Save
          if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            saveTree();
          }
          // Escape: Exit move mode or phase mode
          if (e.key === 'Escape') {
            if (isMoveMode) {
              setIsMoveMode(false);
              setSourceId(null);
            }
            if (isPhaseMode) {
              setIsPhaseMode(false);
            }
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [undo, redo, saveTree, isMoveMode, isPhaseMode]);

      const toggleDottedLine = (lineKey) => {
        setDottedLines(prev => {
          const newSet = new Set(prev);
          if (newSet.has(lineKey)) {
            newSet.delete(lineKey);
          } else {
            newSet.add(lineKey);
          }
          return newSet;
        });
      };

      const findAndUpdate = (n, id, update) => {
        if (!n) return null;
        if (n.id === id) return { ...n, ...update };
        return { ...n, children: n.children ? n.children.map(c => findAndUpdate(c, id, update)) : null };
      };

      const findAndRemove = (n, id) => {
        if (!n || !n.children) return n;
        if (n.children.some(c => c.id === id)) {
          return { ...n, children: n.children.filter(c => c.id !== id).length > 0 ? n.children.filter(c => c.id !== id) : null };
        }
        return { ...n, children: n.children.map(c => findAndRemove(c, id)) };
      };      const makeBlankNode = () => ({ id: generateId(), label: '...', children: null, triangleText: null, triangleSublabels: [], sublabels: [], terminalLocked: false });

      

      const normalizeNode = (n) => {
        if (!n) return null;
        const sublabels = Array.isArray(n.sublabels)
          ? n.sublabels.slice(0, 4)
          : (n.sublabel !== null && n.sublabel !== undefined ? [n.sublabel] : []);
        const triangleSublabels = Array.isArray(n.triangleSublabels)
          ? n.triangleSublabels.slice(0, 4)
          : [];
        const locked = !!n.terminalLocked || sublabels.length >= 2;

        return {
          id: n.id || generateId(),
          label: n.label !== undefined && n.label !== null ? n.label : '...',
          children: n.children ? n.children.map(normalizeNode) : null,
          triangleText: (n.triangleText !== undefined ? n.triangleText : null),
          triangleSublabels,
          sublabels,
          terminalLocked: locked
        };
      };
const updateNode = (id, up) => setTree(prev => findAndUpdate(prev, id, up));
      const addNode = (id, count) => {
  const rec = (n) => {
    if (!n) return null;
    if (n.id === id) {
      if (n.terminalLocked) return n; // terminal nodes cannot receive daughters
      return { ...n, children: Array.from({ length: count }, makeBlankNode) };
    }
    return { ...n, children: n.children ? n.children.map(rec) : null };
  };
  setTree(prev => rec(prev));
};

const addParent =
 (id, arity, side = 'left') => {
        const wrapWithParent = (child) => {
          const parent = makeBlankNode();
          if (arity === 1) {
            parent.children = [child];
          } else {
            const sibling = makeBlankNode();
            parent.children = side === 'right' ? [sibling, child] : [child, sibling];
          }
          return parent;
        };

        const rec = (n) => {
          if (!n) return [n, false];
          if (n.id === id) return [wrapWithParent(n), true];
          if (!n.children) return [n, false];
          let changed = false;
          const newChildren = n.children.map(c => {
            const [nextChild, didChange] = rec(c);
            changed = changed || didChange;
            return nextChild;
          });
          if (!changed) return [n, false];
          return [{ ...n, children: newChildren }, true];
        };

        setTree(prev => {
          const [next, changed] = rec(prev);
          return changed ? next : prev;
        });
      };
const delNode = (id) => {
        if (tree.id === id) {
          setTree(prev => ({...prev, children: null, triangleText: null, sublabels: [], terminalLocked: false}));
        } else {
          setTree(prev => findAndRemove(prev, id));
        }
        setMoves(prev => prev.filter(m => m.from !== id && m.to !== id));
      };

      const toggleTri = (id, mode = 'topdown') => {
        if (mode === 'bottomup') {
          // In bottom-up mode, create a parent node with triangle above the current node
          // The current node becomes the triangle text (no intermediate branch)
          const wrapWithTriangleParent = (child) => {
            const parent = makeBlankNode();
            parent.triangleText = child.label !== '...' ? child.label : '...';
            // Copy sublabels to triangle if present, then clear the child
            parent.children = null;
            // The child node is "absorbed" into the triangle text
            return parent;
          };

          const rec = (n) => {
            if (!n) return [n, false];
            if (n.id === id) {
              // If node already has a triangle, remove it (toggle off)
              if (n.triangleText !== null) {
                return [{ ...n, triangleText: null }, true];
              }
              // Otherwise, replace with a parent that has the node's label as triangle text
              return [wrapWithTriangleParent(n), true];
            }
            if (!n.children) return [n, false];
            let changed = false;
            const newChildren = n.children.map(c => {
              const [nextChild, didChange] = rec(c);
              changed = changed || didChange;
              return nextChild;
            });
            if (!changed) return [n, false];
            return [{ ...n, children: newChildren }, true];
          };

          setTree(prev => {
            // Special case: if the target is the root node
            if (prev.id === id) {
              if (prev.triangleText !== null) {
                return { ...prev, triangleText: null };
              }
              return wrapWithTriangleParent(prev);
            }
            const [next, changed] = rec(prev);
            return changed ? next : prev;
          });
        } else {
          // Top-down mode: original behavior - add triangle below
          const rec = (n) => {
            if (!n) return null;
            if (n.id === id) return n.triangleText !== null ? { ...n, triangleText: null } : { ...n, triangleText: '...', children: null };
            return { ...n, children: n.children ? n.children.map(rec) : null };
          };
          setTree(prev => rec(prev));
        }
      };

      const addSublabel = (id) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            if (current.length >= 4) return n;

            const nextSublabels = [...current, '...'];
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;

            return {
              ...n,
              sublabels: nextSublabels,
              terminalLocked: nextLocked,
              children: nextLocked ? null : n.children
            };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const updateSublabel = (id, idx, value) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            const nextSublabels = current.map((s, i) => (i === idx ? (value || '...') : s));
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;

            return {
              ...n,
              sublabels: nextSublabels,
              terminalLocked: nextLocked,
              children: nextLocked ? null : n.children
            };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const removeSublabel = (id, idx) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            const nextSublabels = current.filter((_, i) => i !== idx);
            // Keep terminal lock sticky once it was triggered (matches "applied more than once blocks")
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;

            return {
              ...n,
              sublabels: nextSublabels,
              terminalLocked: nextLocked,
              children: nextLocked ? null : n.children
            };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      // Triangle sublabel functions
      const addTriangleSublabel = (id) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            if (current.length >= 4) return n;
            return { ...n, triangleSublabels: [...current, '...'] };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const updateTriangleSublabel = (id, idx, value) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            return { ...n, triangleSublabels: current.map((s, i) => (i === idx ? (value || '...') : s)) };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const removeTriangleSublabel = (id, idx) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            return { ...n, triangleSublabels: current.filter((_, i) => i !== idx) };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const draw = useCallback(() => {
        if (!canvasRef.current || !tree) return;
        const canvas = canvasRef.current;
        const rect = canvas.getBoundingClientRect();
        
        const getPos = (id) => {
          const nodeEl = canvas.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return null;
          
          const hasSublabel = nodeEl.getAttribute('data-has-sublabel') === 'true';
          const hasTriangle = nodeEl.querySelector(':scope > .triangle-container') !== null;
          
          // For line start point: use triangle text if present, then sublabel, otherwise main label
          let bottomEl;
          if (hasTriangle) {
            bottomEl = nodeEl.querySelector(':scope > .triangle-container > .node-label .node-display');
          } else if (hasSublabel) {
            const subs = nodeEl.querySelectorAll(':scope > .node-wrapper .node-sublabels .node-display');
            bottomEl = subs && subs.length ? subs[subs.length - 1] : null;
          } else {
            bottomEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display');
          }
          
          // For line end point (top): always use main label
          const topEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display');
          
          if (!bottomEl || !topEl) return null;
          
          const bottomR = bottomEl.getBoundingClientRect();
          const topR = topEl.getBoundingClientRect();
          
          return { 
            x: topR.left + topR.width/2 - rect.left + canvas.scrollLeft, 
            y: topR.top - rect.top + canvas.scrollTop, 
            topR,
            bottomR,
            hasSublabel,
            hasTriangle
          };
        };

        const lines = [];
        const allNodes = canvas.querySelectorAll('[data-node-id]');
        allNodes.forEach(nodeEl => {
          const id = nodeEl.getAttribute('data-node-id');
          const pPos = getPos(id);
          if (!pPos) return;
          const childCont = nodeEl.querySelector(':scope > .node-children');
          if (childCont) {
            childCont.querySelectorAll(':scope > .tree-node').forEach(childEl => {
              const cId = childEl.getAttribute('data-node-id');
              const cPos = getPos(cId);
              if (cPos) {
                // Line starts from bottom of parent's bottommost element (sublabel or label)
                const startY = pPos.bottomR.bottom - rect.top;
                // Line ends at top of child's main label
                const endY = cPos.topR.top - rect.top;
                const lineKey = `${id}-${cId}`;
                const isDotted = dottedLines.has(lineKey);
                lines.push(
                  <g key={lineKey} style={{cursor: 'pointer'}} onDoubleClick={() => toggleDottedLine(lineKey)}>
                    <line 
                      x1={pPos.x} 
                      y1={startY} 
                      x2={cPos.x} 
                      y2={endY} 
                      stroke="transparent" 
                      strokeWidth="15"
                      style={{pointerEvents: 'stroke'}}
                    />
                    <line 
                      x1={pPos.x} 
                      y1={startY} 
                      x2={cPos.x} 
                      y2={endY} 
                      stroke="black" 
                      strokeWidth="1.2"
                      strokeDasharray={isDotted ? "5,4" : "none"}
                      style={{pointerEvents: 'none'}}
                    />
                  </g>
                );
              }
            });
          }
        });

        const arrows = moves.map(m => {
          const s = getPos(m.from); const e = getPos(m.to);
          if (!s || !e) return null;
          const midX = (s.x + e.x) / 2;
          const curve = Math.max(70, Math.abs(e.x - s.x)/2.2);
          const ctrlY = Math.max(s.bottomR.bottom, e.bottomR.bottom) - rect.top + curve;
          const sy = s.bottomR.bottom - rect.top; const ey = e.bottomR.bottom - rect.top;
          const path = `M ${s.x} ${sy} Q ${midX} ${ctrlY} ${e.x} ${ey}`;
          const t = 0.5;
          const bx = (1-t)**2 * s.x + 2*(1-t)*t*midX + t**2 * e.x;
          const by = (1-t)**2 * sy + 2*(1-t)*t*ctrlY + t**2 * ey;
          const arrowKey = `arrow-${m.id}`;
          const isDotted = dottedLines.has(arrowKey);
          return (
            <g key={m.id}>
              <path 
                d={path} 
                fill="none" 
                stroke="transparent" 
                strokeWidth="15"
                style={{cursor: 'pointer', pointerEvents: 'stroke'}}
                onDoubleClick={() => toggleDottedLine(arrowKey)}
              />
              <path 
                d={path} 
                fill="none" 
                stroke="black" 
                strokeWidth="1.5" 
                markerEnd="url(#head)" 
                opacity="0.8"
                strokeDasharray={isDotted ? "5,4" : "none"}
                style={{pointerEvents: 'none'}}
              />
              <g className="arrow-delete-btn" onClick={() => setMoves(prev => prev.filter(x => x.id !== m.id))} transform={`translate(${bx-10},${by-10})`}>
                <rect width="20" height="20" fill="white" stroke="#e0ddd8" /><text x="10" y="15" textAnchor="middle" fontSize="14" fill="#dc2626">×</text>
              </g>
            </g>
          );
        });

        // Draw phase boundary arcs
        const phaseArcs = Array.from(phases).map(nodeId => {
          const nodeEl = canvas.querySelector(`[data-node-id="${nodeId}"]`);
          if (!nodeEl) return null;
          
          // Get the main label element for precise positioning
          const labelEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display');
          if (!labelEl) return null;
          
          const labelRect = labelEl.getBoundingClientRect();
          const x = labelRect.left - rect.left + canvas.scrollLeft;
          const y = labelRect.top - rect.top + canvas.scrollTop;
          const width = labelRect.width;
          
          // Create an arc that sits just above the node label
          const padding = 14;
          const arcHeight = 15;
          const startX = x - padding;
          const startY = y + 5;
          const endX = x + width + padding;
          const endY = y + 5;
          const controlY = y - arcHeight;
          
          const path = `M ${startX} ${startY} Q ${x + width/2} ${controlY} ${endX} ${endY}`;
          const phaseKey = `phase-${nodeId}`;
          const isDotted = !dottedLines.has(phaseKey); // Default is dotted, toggle to solid
          
          return (
            <g key={phaseKey}>
              <path 
                d={path} 
                fill="none" 
                stroke="transparent" 
                strokeWidth="12"
                style={{cursor: 'pointer', pointerEvents: 'stroke'}}
                onDoubleClick={() => toggleDottedLine(phaseKey)}
              />
              <path 
                d={path} 
                fill="none" 
                stroke="black" 
                strokeWidth="1.5" 
                strokeDasharray={isDotted ? "5,3" : "none"}
                opacity="0.8"
                style={{pointerEvents: 'none'}}
              />
              <g className="arrow-delete-btn" onClick={() => togglePhase(nodeId)} transform={`translate(${x + width/2 - 10},${controlY - 18})`}>
                <rect width="20" height="20" fill="white" stroke="#e0ddd8" /><text x="10" y="15" textAnchor="middle" fontSize="14" fill="#dc2626">×</text>
              </g>
            </g>
          );
        });

        setSvgLines(<><defs><marker id="head" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" /></marker></defs>{lines}{arrows}{phaseArcs}</>);
      }, [tree, moves, phases, dottedLines]);

      useLayoutEffect(() => { draw(); }, [tree, moves, phases, dottedLines, draw]);
      useEffect(() => { window.addEventListener('resize', draw); return () => window.removeEventListener('resize', draw); }, [draw]);

      const load = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            isUndoRedo.current = true;
            setTreeInternal(normalizeNode(data.tree || data));
            setMovesInternal(data.moves || []);
            setPhasesInternal(new Set(data.phases || []));
            setDottedLinesInternal(new Set(data.dottedLines || []));
            setHistory([]);
            setHistoryIndex(-1);
            setTimeout(() => { isUndoRedo.current = false; }, 0);
          } catch(err) { alert("Invalid JSON file"); }
        };
        reader.readAsText(file);
        e.target.value = "";
      };

      return (
        <div className="container">
          <header className="header">
            <img src={LOGO_URL} alt="Kilmer" className="header-logo" onError={e => e.target.style.display='none'} />
          </header>

          <div className="toolbar">
            <button className="btn btn-primary" onClick={() => {setTree({id: generateId(), label: '...', children: null, triangleText: null, sublabels: [], terminalLocked: false}); setMoves([]); setPhases(new Set()); setDottedLines(new Set()); setHistory([]); setHistoryIndex(-1);}}>New Tree</button>
            <div className="toolbar-divider" />
            <button className="btn" onClick={undo} disabled={!canUndo} title="Undo (Ctrl+Z)">↶</button>
            <button className="btn" onClick={redo} disabled={!canRedo} title="Redo (Ctrl+Y)">↷</button>
            <div className="toolbar-divider" />
            <div className="build-switch" title="Build direction">
              <span className={`build-switch-label ${buildMode === 'topdown' ? 'active' : ''}`}>Top-down</span>
              <label className="switch" aria-label="Toggle build direction">
                <input
                  type="checkbox"
                  checked={buildMode === 'bottomup'}
                  onChange={(e) => setBuildMode(e.target.checked ? 'bottomup' : 'topdown')}
                />
                <span className="slider" />
              </label>
              <span className={`build-switch-label ${buildMode === 'bottomup' ? 'active' : ''}`}>Bottom-up</span>
            </div>
            <div className="toolbar-divider" />
            <button className={`btn ${isMoveMode ? 'active-mode' : ''}`} onClick={() => {setIsMoveMode(!isMoveMode); setIsPhaseMode(false); setSourceId(null);}} disabled={!tree}>
              {isMoveMode ? (sourceId ? 'Select Target...' : 'Select Source...') : 'Move'}
            </button>
            <button className={`btn ${isPhaseMode ? 'active-mode' : ''}`} onClick={() => {setIsPhaseMode(!isPhaseMode); setIsMoveMode(false); setSourceId(null);}} disabled={!tree}>
              {isPhaseMode ? 'Click a Phase...' : 'Phase'}
            </button>


            <div className="toolbar-divider" />
            <button className="btn" onClick={() => fileRef.current.click()}>Load .kilmer</button>
            <input type="file" ref={fileRef} style={{display:'none'}} accept=".kilmer,.json,application/json,text/plain,*/*" onChange={load} />
            <button className="btn" onClick={saveTree} disabled={!tree} title="Save (Ctrl+S)">Save .kilmer</button>
            <button className="btn" onClick={async () => {
              const filename = (prompt('Enter filename:', 'syntax_tree') || 'syntax_tree').replace(/\s+/g, '_');
              const el = canvasRef.current;
              
              // Function to copy computed styles to inline styles
              const copyComputedStyles = (source, target, skipBorderStyles = false) => {
                const computed = window.getComputedStyle(source);
                for (let i = 0; i < computed.length; i++) {
                  const prop = computed[i];
                  // Skip border-related styles if requested
                  if (skipBorderStyles && (prop.startsWith('border') || prop === 'box-shadow' || prop === 'outline')) {
                    continue;
                  }
                  target.style.setProperty(prop, computed.getPropertyValue(prop));
                }
              };
              
              // Deep clone with computed styles
              const cloneWithStyles = (element) => {
                const clone = element.cloneNode(false);
                const isPill = element.classList && element.classList.contains('sublabel-pill');
                copyComputedStyles(element, clone, isPill);
                
                for (let child of element.childNodes) {
                  if (child.nodeType === Node.ELEMENT_NODE) {
                    clone.appendChild(cloneWithStyles(child));
                  } else {
                    clone.appendChild(child.cloneNode(true));
                  }
                }
                return clone;
              };
              
              const clone = cloneWithStyles(el);
              
              // Remove UI elements from clone
              clone.querySelectorAll('.node-actions, .arrow-delete-btn').forEach(x => x.remove());
              
              // Remove pill delete buttons
              clone.querySelectorAll('.pill-x').forEach(x => x.remove());
              
              // Ensure pills have clean styling and proper alignment
              clone.querySelectorAll('.sublabel-pill').forEach(pill => {
                pill.style.border = 'none';
                pill.style.borderWidth = '0';
                pill.style.borderStyle = 'none';
                pill.style.borderRadius = '0';
                pill.style.background = 'transparent';
                pill.style.backgroundColor = 'transparent';
                pill.style.padding = '0';
                pill.style.boxShadow = 'none';
                pill.style.outline = 'none';
                pill.style.display = 'flex';
                pill.style.alignItems = 'center';
                pill.style.justifyContent = 'center';
              });
              
              // Create container for the clone
              const container = document.createElement('div');
              container.style.cssText = `
                position: fixed;
                left: 0;
                top: 0;
                z-index: -9999;
                pointer-events: none;
                overflow: visible;
                background: white;
              `;
              container.appendChild(clone);
              document.body.appendChild(container);
              
              // Wait for rendering
              await new Promise(resolve => setTimeout(resolve, 150));
              
              try {
                const cv = await html2canvas(clone, {
                  backgroundColor: '#ffffff',
                  scale: 2,
                  useCORS: true,
                  logging: false
                });
                const a = document.createElement('a'); 
                a.download = `${filename}.png`; 
                a.href = cv.toDataURL('image/png'); 
                a.click();
              } finally {
                document.body.removeChild(container);
              }
            }} disabled={!tree}>Export PNG</button>
          </div>

          <div className="tree-canvas" ref={canvasRef}>
            <svg width="100%" height="100%" style={{position:'absolute', top:0, left:0, pointerEvents:'none', zIndex:1, overflow:'visible'}}>{svgLines}</svg>
            {tree ? <TreeNode node={tree} isRoot={true} {...{updateNode, addNode, addParent, buildMode, toggleTri, addSublabel, updateSublabel, removeSublabel, addTriangleSublabel, updateTriangleSublabel, removeTriangleSublabel, delNode, isMoveMode, isPhaseMode, sourceId, onNodeClick: (id) => {
              if (!sourceId) setSourceId(id);
              else if (sourceId === id) setSourceId(null);
              else { setMoves(p => [...p, {id: generateId(), from: sourceId, to: id}]); setSourceId(null); setIsMoveMode(false); }
            }, onPhaseClick: (id) => {
              togglePhase(id);
              setIsPhaseMode(false);
            }}} /> : <div style={{color:'#999'}}>Click <strong>New Tree</strong> to start a new diagram or <strong>Load a .kilmer file</strong> to continue editing a previous one.</div>}
          </div>

          {/* Redesigned Instructions Panel - Collapsible */}
          <div className="instructions-panel">
            <button className="instructions-header" onClick={() => setShowInstructions(prev => !prev)}>
              <span>Quick Reference</span>
              <span className={`collapse-icon ${showInstructions ? 'expanded' : ''}`}>▶</span>
            </button>
            {showInstructions && (
              <div className="instructions-grid">
              
              <div className="instruction-card">
                <h4><span className="icon">⑃</span> Building the Tree</h4>
                <ul>
                  <li>Hover over any node to reveal action buttons.</li>
                  <li>Use <code>│</code> for a single daughter or <code>⑃</code> for binary branching.</li>
                  <li>The <code>△</code> button creates a triangle for unanalyzed constituents.</li>
                  <li>Double-click any branch line to toggle dotted style.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">A</span> Editing Labels</h4>
                <ul>
                  <li>Click any label to edit.</li>
                  <li>Confirm with <span className="keyboard-hint"><span class="key">Enter</span></span> or cancel with <span className="keyboard-hint"><span class="key">Esc</span></span> to revert.</li>
                  <li>Use <code>+₂</code> to add a secondary label below the main one.</li>
                </ul>
              </div>

              {/* NEW: Build modes */}
              <div className="instruction-card">
                <h4><span className="icon">⇅</span> Build Modes</h4>
                <ul>
                  <li>Use the <strong>Top-down / Bottom-up</strong> switch in the top toolbar to change the construction mode at any time.</li>
                  <li><strong>Top-down</strong>: <code>│</code>, <code>⑃</code>, and <code>△</code> create <strong>daughters</strong> from the selected node.</li>
                  <li><strong>Bottom-up</strong>: <code>│</code>, <code>→⑃</code>/<code>⑃←</code>, and <code>△</code> create a <strong>parent</strong> above the selected node.</li>
                  <li>The arrows in <code>→⑃</code> and <code>⑃←</code> indicate where the <strong>sibling</strong> will appear (left or right).</li>
                  <li>In Bottom-up mode, the node tools appear <strong>above</strong> the node. In Top-down mode, the node tools appear <strong>below</strong>.</li>
                </ul>
              </div>

              {/* NEW: Multiple bottom labels (stacked pills) */}
              <div className="instruction-card">
                <h4><span className="icon">+₂</span> Multiple Bottom Labels</h4>
                <ul>
                  <li>Use <code>+₂</code> to add up to <strong>4</strong> bottom labels (“pills”) under a node.</li>
                  <li>Each pill is <strong>editable</strong> (click to edit) and can be removed with its <code>×</code>.</li>
                  <li>If a node reaches <strong>2+</strong> bottom labels, it becomes <strong>terminal (locked)</strong>:
                  existing daughters (if any) are removed, and no new daughters can be added in Top-down mode.</li>
                  <li>Bottom-up wrapping still works on locked nodes (it adds a parent, not daughters).</li>
                </ul>
              </div>

              <div className="instruction-card text-formatting-card">
                <h4><span className="icon">✦</span> Text Formatting</h4>
                <div className="formatting-columns">
                  <ul>
                    <li><code>**text**</code> <span class="example"><span class="arrow">→</span> <span class="result"><b>bold</b></span></span></li>
                    <li><code>*text*</code> <span class="example"><span class="arrow">→</span> <span class="result"><i>italics</i></span></span></li>
                    <li><code>X_i</code> or <code>X_i_</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sub>i</sub></span></span></li>
                    <li><code>X¨n</code> or <code>X¨n¨</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sup>n</sup></span></span></li>
                    <li><code>#X#</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="overline">X</span></span></span></li>
                    <li><code>##X##</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="double-overline">X</span></span></span></li>
                    <li><code>=X=</code> <span class="example"><span class="arrow">→</span> <span class="result"><s>X</s></span></span></li>
                  </ul>
                  <ul>
                    <li className="combining-header">Styles can be combined:</li>
                    <li><code>**X**_i_</code> <span class="example"><span class="arrow">→</span> <span class="result"><b>X</b><sub>i</sub></span></span></li>
                    <li><code>*X*_i_</code> <span class="example"><span class="arrow">→</span> <span class="result"><i>X</i><sub>i</sub></span></span></li>
                    <li><code>X¨*n*¨</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sup><i>n</i></sup></span></span></li>
                    <li><code>#*XP*#</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="overline"><i>XP</i></span></span></span></li>
                    <li><code>=*t*_i_=</code> <span class="example"><span class="arrow">→</span> <span class="result"><s><i>t</i><sub>i</sub></s></span></span></li>
                  </ul>
                </div>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">⤳</span> Movement Arrows</h4>
                <ul>
                  <li>Activate <strong>Move</strong>, then click the source node (e.g., a trace) followed by the target.</li>
                  <li>Arrows curve beneath the tree.</li>
                  <li>Double-click on the line to toggle dotted style.</li>
                  <li>Click <code>×</code> on any arrow to remove it.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">◠</span> Phase Boundaries</h4>
                <ul>
                  <li>Activate <strong>Phase</strong>, then click a phase head (vP, CP).</li>
                  <li>A dashed arc marks the phase boundary. Double-click to make it solid.</li>
                  <li>Click <code>×</code> on the arc to remove it.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">✕</span> Deleting Nodes</h4>
                <ul>
                  <li>The red <code>✕</code> removes a node and all its descendants.</li>
                  <li>On the root node, it clears the entire structure while preserving the root label.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">◰</span> Saving Your Work</h4>
                <ul>
                  <li><strong>Save</strong> exports a <code>.kilmer</code> file for later editing.</li>
                  <li><strong>Export PNG</strong> generates a clean image for documents and presentations.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">⌨</span> Keyboard Shortcuts</h4>
                <div style={{ display: 'flex', justifyContent: 'flex-start', gap: '40px' }}>
                  <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                    <li style={{ marginBottom: '5px', opacity: 0.7, fontSize: '0.8em' }}>Windows / Linux</li>
                    <li><span className="key">Ctrl</span>+<span className="key">Z</span> Undo</li>
                    <li><span className="key">Ctrl</span>+<span className="key">Y</span> Redo</li>
                    <li><span className="key">Ctrl</span>+<span className="key">S</span> Save</li>
                  </ul>

                  <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                    <li style={{ marginBottom: '5px', opacity: 0.7, fontSize: '0.8em' }}>macOS</li>
                    <li><span className="key">⌘</span>+<span className="key">Z</span> Undo</li>
                    <li><span className="key">⌘</span>+<span className="key">Shift</span>+<span className="key">Z</span> Redo</li>
                    <li><span className="key">⌘</span>+<span className="key">S</span> Save</li>
                  </ul>
                </div>

                <hr style={{ margin: '15px 0', border: '0', borderTop: '1px solid #eee' }} />

                <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                  <li><span className="key">Esc</span> Exit Move Mode</li>
                </ul>
              </div>
            </div>
          )}
        </div>

        <footer className="footer">
          <p>Carlos González Vergara (<strong><a href="mailto:cgonzalv@uc.cl">cgonzalv@uc.cl</a></strong>)</p>
          <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer">
            <img 
              src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nc-nd.svg" 
              alt="CC BY-NC-ND 4.0" 
            />
          </a>
        </footer>
      </div>
    );
  };

  ReactDOM.createRoot(document.getElementById('root')).render(<KilmerApp />);
</script>
</body>
</html>