<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kilmer - Syntactic Tree Builder</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Source+Sans+3:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --color-bg: #faf9f7;
      --color-surface: #ffffff;
      --color-text: #1a1a1a;
      --color-text-muted: #6b6b6b;
      --color-accent: #1a472a;
      --color-border: #e0ddd8;
      --color-select: #2563eb;
      --font-display: 'Crimson Pro', Georgia, serif;
      --font-body: 'Source Sans 3', system-ui, sans-serif;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: var(--font-body); background-color: var(--color-bg); color: var(--color-text); min-height: 100vh; overflow-x: hidden; }
    .container { max-width: 1300px; margin: 0 auto; padding: 40px 24px; }

    .header { text-align: center; margin-bottom: 24px; }
    .header-logo { max-width: 320px; height: auto; }

    /* =================================
       TOOLBAR Y CONTROLES
       ================================= */
    .toolbar {
      background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px;
      padding: 16px 24px; margin-bottom: 8px; display: flex; gap: 10px; flex-wrap: wrap;
      align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.04); position: sticky; top: 20px; z-index: 100;
      color: var(--color-text);
    }

    /* Barra de estado de modo (Move/Phase) */
    .mode-status-bar {
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
      border: 1px solid #86efac;
      border-radius: 8px;
      padding: 10px 20px;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      font-family: var(--font-body);
      font-size: 14px;
      font-weight: 500;
      color: #15803d;
      box-shadow: 0 2px 4px rgba(34, 197, 94, 0.08);
      animation: slideDown 0.2s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    .mode-status-bar .status-icon {
      font-size: 16px;
    }

    .mode-status-bar .status-step {
      background: white;
      padding: 2px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      color: var(--color-accent);
      border: 1px solid #bbf7d0;
    }

    .mode-status-bar button {
      margin-left: auto;
      background: white;
      border: 1px solid #86efac;
      border-radius: 6px;
      padding: 4px 12px;
      font-size: 12px;
      font-weight: 600;
      color: #15803d;
      cursor: pointer;
      transition: all 0.15s;
    }

    .mode-status-bar button:hover {
      background: var(--color-accent);
      color: white;
      border-color: var(--color-accent);
    }

    /* Botones principales */
    .btn {
      font-family: var(--font-body); padding: 8px 16px; border: 1px solid var(--color-border);
      border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;
      background: var(--color-surface); transition: all 0.2s;
    }

    .btn:hover:not(:disabled) { border-color: var(--color-text); transform: translateY(-1px); }
    .btn-primary { background: var(--color-accent); color: white; border-color: var(--color-accent); }
    .btn.active-mode { background: #16a34a; color: white; border-color: #16a34a; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .toolbar-divider {
      width: 1px;
      height: 28px;
      background: linear-gradient(to bottom, transparent 5%, #c0bdb8 20%, #c0bdb8 80%, transparent 95%);
      margin: 0 10px;
    }

    /* Control segmentado (Top-down/Bottom-up) */
    .segmented-control {
      display: inline-flex;
      border: 1px solid var(--color-border);
      border-radius: 6px;
      overflow: hidden;
      background: #e0e0e0;
    }

    .segmented-control button {
      padding: 8px 16px;
      border: none;
      background: transparent;
      font-family: var(--font-body);
      font-size: 14px;
      font-weight: 600;
      color: var(--color-text-muted);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .segmented-control button:hover:not(.active) {
      background: rgba(255,255,255,0.5);
      color: var(--color-text);
    }

    .segmented-control button.active {
      background: var(--color-accent);
      color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }

    /* =================================
       CANVAS Y CONTROLES DE ZOOM
       ================================= */
    .tree-canvas {
      background: var(--color-surface); border: 1px solid var(--color-border); border-radius: 12px;
      min-height: 267px; padding: 53px 40px; display: flex; align-items: flex-start; justify-content: flex-start;
      position: relative; overflow-x: auto; overflow-y: hidden;
      }

    /* Controles de zoom */
    .zoom-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      align-items: center;
      gap: 2px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--color-border);
      border-radius: 8px;
      padding: 4px;
      z-index: 200;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    .zoom-controls.visible {
      opacity: 0.6;
      pointer-events: auto;
    }

    .zoom-controls.visible:hover {
      opacity: 1;
    }

    /* Indicador de auto-guardado - esquina superior izquierda */
    .autosave-indicator {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid var(--color-border);
      border-radius: 8px;
      padding: 6px 12px;
      z-index: 200;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      font-size: 12px;
      color: #6b6b6b;
    }

    .autosave-indicator.visible {
      opacity: 0.6;
      pointer-events: auto;
    }

    .autosave-indicator.visible:hover {
      opacity: 1;
    }

    .autosave-indicator span {
      color: #16a34a;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 600;
      color: var(--color-text);
      border-radius: 4px;
      transition: background 0.15s;
    }

    .zoom-btn:hover:not(:disabled) {
      background: rgba(0,0,0,0.08);
    }

    .zoom-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .zoom-indicator {
      min-width: 44px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      color: var(--color-text-muted);
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.15s, color 0.15s;
      user-select: none;
    }

    .zoom-indicator:hover {
      background: rgba(0,0,0,0.08);
      color: var(--color-text);
    }

    .zoom-stage {
      position: relative;
      margin: 0 auto;
    }

    .zoom-wrapper {
      position: relative;
      min-width: 100%;
      min-height: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .zoom-container {
      position: absolute;
      left: 50%;
      transform-origin: top center;
    }

    /* =================================
       ÁRBOL SINTÁCTICO - NODOS
       ================================= */
    .tree-node { display: flex; flex-direction: column; align-items: center; position: relative; }
    .node-wrapper { position: relative; padding-bottom: 15px; }
    .node-wrapper.has-sublabels { padding-bottom: 8px; }
    .node-content { display: flex; flex-direction: column; align-items: center; }
    /* Etiquetas de nodos */
    .node-label { font-family: var(--font-display); font-size: 20px; min-height: 1.5em; display: flex; align-items: center; justify-content: center; position: relative; z-index: 10; }

    /* Keep the display element in layout when editing, just make it invisible */
    .node-label.is-editing .node-display {
      opacity: 0;
      pointer-events: none;
    }

    /* Sub-etiquetas (secondary labels) */
    .node-sublabels {
      font-family: var(--font-display);
      font-size: 15px;
      color: var(--color-text-muted);
      min-height: 1.2em;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 10;
      margin-top: -2px;
      gap: 4px;
    }

    .sublabel-pill {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Keep the display element in layout when editing, just make it invisible */
    .sublabel-pill:has(input) .node-display {
      opacity: 0;
      pointer-events: none;
    }

    .sublabel-pill .node-display {
      padding: 0;
      border: 0;
      cursor: pointer;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 100px;
      text-align: center;
    }

    .sublabel-pill .node-display:hover { background: transparent; }

    .pill-x {
      position: absolute;
      right: -28px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      border: 1px solid var(--color-border);
      border-radius: 4px;
      background: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      line-height: 1;
      padding: 0;
      color: #dc2626;
      opacity: 0;
      transition: opacity 0.15s, background 0.15s, border-color 0.15s, color 0.15s;
    }

    .pill-x:hover {
      opacity: 1 !important;
      background: #dc2626;
      border-color: #dc2626;
      color: white;
      font-weight: bold;
    }
    
    .sublabel-pill:hover .pill-x {
      opacity: 1;
    }

    .node-display { padding: 4px 10px; border-radius: 4px; border: 2px solid transparent; cursor: pointer; }
    .node-display:hover { background: rgba(0,0,0,0.05); }
    .node-display.is-source { border-color: #16a34a; background: rgba(22, 163, 74, 0.1); }
    .node-display.move-active { cursor: crosshair; }
    .node-display.placeholder {
      color: #888;
      border: 1px dashed #ccc;
      background: rgba(37, 99, 235, 0.04);
      padding: 4px 12px;
      border-radius: 4px;
    }

    .node-display.placeholder::before {
      content: "✎ ";
      opacity: 0.6;
    }

    .node-display.placeholder:hover {
      color: var(--color-accent);
    }

    .node-sublabels .node-display { font-size: 15px; }

    .node-display i { font-style: italic; }
    .node-display sub { font-size: 0.7em; vertical-align: sub; line-height: 0; }
    .node-display sup { font-size: 0.7em; vertical-align: super; line-height: 0; }
    .node-display .overline { text-decoration: overline; }
    .node-display .double-overline {
      text-decoration: overline;
      border-top: 1.5px solid currentColor;
      padding-top: 2px;
    }

    .node-display s { text-decoration: line-through; }

    .node-label input, .node-sublabels input { font-family: var(--font-display); text-align: center; outline: none; border: 2px solid var(--color-accent); border-radius: 4px; padding: 4px 10px; }
    .node-label input { font-size: 18px; }
    .node-sublabels input { font-size: 14px; }

    /* Overlay inputs: keep the normal display element in-flow so the tree doesn't re-center/reflow while typing */
    .label-input-overlay {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: auto;
      min-width: 80px;
      max-width: 100px;
      box-sizing: border-box;
      margin: 0;
      border: 2px solid var(--color-accent);
      border-radius: 4px;
      padding: 4px 10px;
      font-family: var(--font-display);
      text-align: center;
      outline: none;
      background: rgba(255,255,255,0.98);
      z-index: 20;
    }

    .node-label .label-input-overlay { font-size: 18px; }

    .sublabel-input-overlay {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: auto;
      min-width: 80px;
      max-width: 100px;
      box-sizing: border-box;
      margin: 0;
      border: 2px solid var(--color-accent);
      border-radius: 4px;
      padding: 2px 8px;
      font-family: var(--font-display);
      text-align: center;
      outline: none;
      background: rgba(255,255,255,0.98);
      z-index: 20;
      font-size: 14px;
    }

    /* Acciones de nodo */
    .node-actions {
      position: absolute; top: 65%; left: 50%; transform: translateX(-50%);
      display: flex; gap: 4px; opacity: 0; pointer-events: none;
      transition: opacity 0.2s; background: white; padding: 6px; border-radius: 8px;
      border: 1px solid var(--color-border); box-shadow: 0 4px 12px rgba(0,0,0,0.12); z-index: 50;
    }

    .node-content.has-sublabels .node-actions { top: 90%; }
    .node-content:hover .node-actions, .node-actions:hover, .triangle-label:hover .node-actions { opacity: 1; pointer-events: auto; }
    .triangle-label .node-actions { top: 80%; }
    .triangle-label.has-triangle-sublabels .node-actions { top: 95%; }
    .node-content.bottomup .node-actions {
      top: 8px;
      left: 50%;
      transform: translate(-50%, -100%);
    }

    .action-btn { min-width: 32px; height: 32px; padding: 0 6px; border: 1px solid var(--color-border); border-radius: 6px; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; gap: 1px; }
    .action-btn:hover { background: var(--color-accent); color: white; }
    .action-btn.danger:hover { background: #dc2626; border-color: #dc2626; color: white; }
    .action-btn.active { background: var(--color-accent); color: white; }

    .node-children { display: flex; justify-content: center; gap: 40px; padding-top: 40px; position: relative; }
    .node-wrapper.has-sublabels + .node-children { padding-top: 22px; }

    /* =================================
       TRIÁNGULOS Y ELEMENTOS ESPECIALES
       ================================= */
    .triangle-container { display: flex; flex-direction: column; align-items: center; margin-top: -15px; }
    /* parent has sublabels -> push triangle down */
    .node-wrapper.has-sublabels + .triangle-container { margin-top: -5px; }

    .triangle-svg { overflow: visible; margin-bottom: 5px; }
    .triangle-label { position: relative; display: flex; flex-direction: column; align-items: center; }
    /* Sub-etiquetas (secondary labels) */
    .triangle-label .node-sublabels { margin-top: 2px; }

    .arrow-delete-btn { cursor: pointer; pointer-events: auto; opacity: 0; transition: opacity 0.15s; }
    .arrow-delete-btn rect { fill: white; stroke: var(--color-border); rx: 4; }
    .arrow-delete-btn:hover rect { fill: #dc2626; stroke: #dc2626; }
    .arrow-delete-btn:hover text { fill: white; font-weight: bold; }
    .arrow-group:hover .arrow-delete-btn,
    .phase-group:hover .arrow-delete-btn,
    .arrow-delete-btn:hover { opacity: 1; }

    /* =================================
       PANEL DE INSTRUCCIONES
       ================================= */
    .instructions-panel {
      margin-top: 48px;
      background: linear-gradient(135deg, #fdfcfb 0%, #f7f6f3 100%);
      border: 1px solid var(--color-border);
      border-radius: 16px;
      overflow: hidden;
    }

    .instructions-header {
      background: var(--color-accent);
      color: white;
      border-radius: 12px;
      padding: 16px 24px;
      font-family: var(--font-display);
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      width: 100%;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }

    .instructions-header:hover {
      background: #153d23;
    }

    .instructions-panel:has(.collapse-icon.expanded) .instructions-header {
      border-radius: 12px 12px 0 0;
    }

    .collapse-icon {
      font-size: 0.9rem;
      transition: transform 0.3s ease;
    }

    .collapse-icon.expanded {
      transform: rotate(90deg);
    }

    .instructions-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1px;
      background: var(--color-border);
    }

    @media (max-width: 700px) {
      .instructions-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      .container { padding: 20px 12px; }
      .header { margin-bottom: 24px; }
      .header-logo { max-width: 240px; }
      .toolbar {
        padding: 12px 16px;
        gap: 8px;
        position: static;
      }
    /* Botones principales */
      .btn {
        padding: 8px 12px;
        font-size: 13px;
      }
      .segmented-control button {
        padding: 8px 12px;
        font-size: 13px;
      }
    /* Barra de estado de modo (Move/Phase) */
      .mode-status-bar {
        padding: 8px 12px;
        font-size: 13px;
        flex-direction: column;
        gap: 8px;
        text-align: center;
        margin-bottom: 16px;
      }
      .mode-status-bar .status-step {
        margin-top: 4px;
      }
      .mode-status-bar button {
        margin-left: 0;
        width: 100%;
        margin-top: 4px;
      }
      .autosave-indicator {
        font-size: 11px;
        padding: 4px 8px;
      }
      .tree-canvas {
        min-height: 400px;
        padding: 40px 20px;
        overflow-x: auto;
      }
    /* Etiquetas de nodos */
      .node-label { font-size: 16px; }
    /* Sub-etiquetas (secondary labels) */
      .node-sublabels { font-size: 13px; }
      .node-children { gap: 24px; padding-top: 30px; }
      .instructions-grid {
        grid-template-columns: 1fr;
      }
      .instructions-header { padding: 12px 16px; font-size: 1.1rem; }
      .instruction-card { padding: 16px; }
    }

    .instruction-card {
      background: white;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .instruction-card h4 {
      font-family: var(--font-display);
      font-size: 1.1rem; /* Aumentado ligeramente */
      font-weight: 600;
      color: var(--color-accent);
      display: flex;
      align-items: center;
      gap: 12px; /* Más espacio entre ícono y texto */
      margin-bottom: 8px;
    }

    .instruction-card h4 .icon {
      width: 32px;  /* Antes 24px */
      height: 32px; /* Antes 24px */
      background: var(--color-accent);
      color: white;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px; /* Antes 14px */
      font-family: var(--font-body);
      flex-shrink: 0; /* Evita que el ícono se encoja */
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Un toque de relieve */
    }

    .instruction-card p {
      font-size: 14px;
      line-height: 1.6;
      color: var(--color-text-muted);
    }

    .instruction-card ul {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 14px;
      line-height: 1.6;
      color: var(--color-text-muted);
    }

    .instruction-card li {
      position: relative;
      padding-left: 16px;
      margin-bottom: 4px;
    }

    .instruction-card li::before {
      content: "•";
      position: absolute;
      left: 0;
      color: var(--color-accent);
      font-weight: bold;
    }

    .instruction-card li:last-child {
      margin-bottom: 0;
    }

    .instruction-card code {
      display: inline-block;
      background: #f5f4f0;
      padding: 1px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 13px;
      color: var(--color-text);
      border: 1px solid #e8e6e1;
    }

    .instruction-card .example {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .instruction-card .example .arrow {
      color: var(--color-accent);
      font-size: 12px;
    }

    .instruction-card .example .result {
      font-family: var(--font-display);
      font-size: 15px;
    }

    .instruction-card .example .result i { font-style: italic; }
    .instruction-card .example .result sub { font-size: 0.7em; vertical-align: sub; }
    .instruction-card .example .result sup { font-size: 0.7em; vertical-align: super; }
    .instruction-card .example .result .overline { text-decoration: overline; }
    .instruction-card .example .result .double-overline { text-decoration: overline; border-top: 1.5px solid currentColor; padding-top: 2px; }
    .instruction-card .example .result s { text-decoration: line-through; }

    .text-formatting-card .formatting-columns {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    .text-formatting-card .formatting-columns ul {
      margin: 0;
    }

    .text-formatting-card .combining-header {
      font-weight: 600;
      color: var(--color-text);
      margin-bottom: 4px;
      padding-left: 0;
    }

    .text-formatting-card .combining-header::before {
      content: none;
    }

    @media (max-width: 600px) {
      .text-formatting-card .formatting-columns {
        grid-template-columns: 1fr;
        gap: 12px;
      }
    }

    .keyboard-hint {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .key {
      display: inline-block;
      background: linear-gradient(180deg, #fafafa 0%, #e8e8e8 100%);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 8px;
      font-size: 12px;
      font-family: var(--font-body);
      font-weight: 600;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }

    .instruction-card li .key {
      margin-right: 2px;
    }

    .instruction-card li .key + .key {
      margin-left: 0;
    }

    /* Quita el punto verde de las listas de atajos de teclado */
    .shortcut-list li::before {
      content: none !important;
    }

    /* Ajuste adicional para que los atajos no tengan el espacio de la viñeta */
    .shortcut-list li {
    padding-left: 0 !important;
    }

    /* =================================
       FOOTER
       ================================= */
    .footer {
      margin-top: 48px;
      padding: 24px 0;
      text-align: center;
      border-top: 1px solid var(--color-border);
      color: var(--color-text-muted);
      font-size: 14px;
    }

    .footer strong { color: var(--color-text); }
    .footer a { color: var(--color-accent); text-decoration: none; }
    .footer a:hover { text-decoration: underline; }
    .footer img {
      opacity: 0.8;
      transition: opacity 0.2s;
      display: block;
      margin: 12px auto 0;
      height: 31px;
      width: auto;
    }

    .footer img:hover { opacity: 1; }

    /* --- FIXES: prevent accidental text selection on double click (without breaking input editing) --- */
    .zoom-wrapper, .zoom-container, svg, .node-display {
      -webkit-user-select: none;
      user-select: none;
    }

    .label-input-overlay, .sublabel-input-overlay {
      -webkit-user-select: text;
      user-select: text;
    }

    /* --- FIXES: keep placeholder nodes from rendering too narrow before editing --- */
    .node-display { flex: 0 0 auto; }
    .node-display.placeholder {
      min-width: 72px;
      justify-content: center;
      display: inline-flex;
      white-space: nowrap;
    }

    /* =================================
       MEDIA QUERIES - RESPONSIVE
       ================================= */
    @media (max-width: 900px) {
      .tree-canvas { width: 100%; }
    }

</style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useCallback, useEffect, useLayoutEffect } = React;

    const LOGO_URL = "kilmer_logo.png";
    const generateId = () => Math.random().toString(36).substring(2, 11);

    const formatLabel = (text) => {
      if (!text) return '';
      return text
        .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
        .replace(/\*(.*?)\*/g, '<i>$1</i>')
        .replace(/=(.*?)=/g, '<s>$1</s>')
        .replace(/##(.*?)##/g, '<span class="double-overline">$1</span>')
        .replace(/#(.*?)#/g, '<span class="overline">$1</span>')
        .replace(/¨(.*?)¨/g, '<sup>$1</sup>')
        .replace(/¨(.*?)(\s|$)/g, '<sup>$1</sup>$2')
        .replace(/_(.*?)_/g, '<sub>$1</sub>')
        .replace(/_(.*?)(\s|$)/g, '<sub>$1</sub>$2');
    };

    const measureText = (text, font = "20px 'Crimson Pro', Georgia, serif") => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = font;
      const plainText = text
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/=(.*?)=/g, '$1')
        .replace(/##(.*?)##/g, '$1')
        .replace(/#(.*?)#/g, '$1')
        .replace(/¨(.*?)¨/g, '$1')
        .replace(/¨(.*?)(\s|$)/g, '$1$2')
        .replace(/_(.*?)_/g, '$1')
        .replace(/_(.*?)(\s|$)/g, '$1$2');
      return ctx.measureText(plainText).width;
    };

    const TreeNode = ({
      node, isRoot, updateNode, addNode, addParent, addSublabel, updateSublabel, removeSublabel,
      addTriangleSublabel, updateTriangleSublabel, removeTriangleSublabel, buildMode, toggleTri,
      delNode, isMoveMode, isPhaseMode, sourceId, onNodeClick, onPhaseClick, onEditStart, onEditEnd
    }) => {
      const [editLabel, setEditLabel] = useState(false);
      const [editTri, setEditTri] = useState(false);
      const [editSubIdx, setEditSubIdx] = useState(null);
      const [subEditVal, setSubEditVal] = useState('');
      const [editTriSubIdx, setEditTriSubIdx] = useState(null);
      const [triSubEditVal, setTriSubEditVal] = useState('');
      const [val, setVal] = useState(node.label);
      const [tVal, setTVal] = useState(node.triangleText || '');

      // Keep a stable display width while editing: we render the previous (pre-edit) value
      // in the normal display element, and place the input on top as an overlay.
      const editBaseLabelRef = useRef('');
      const editBaseSubRef = useRef('...');
      const editBaseTriRef = useRef('...');
      const editBaseTriSubRef = useRef('...');

      useEffect(() => {
        setVal(node.label);
        setTVal(node.triangleText || '');
        setEditSubIdx(null);
        setSubEditVal('');
        setEditTriSubIdx(null);
        setTriSubEditVal('');
      }, [node.id, node.label, node.triangleText]);

      const sublabels = Array.isArray(node.sublabels) ? node.sublabels : [];
      const hasSublabels = sublabels.length > 0;
      const triangleSublabels = Array.isArray(node.triangleSublabels) ? node.triangleSublabels : [];
      const hasTriangleSublabels = triangleSublabels.length > 0;
      const isSpecialMode = isMoveMode || isPhaseMode;

      const startEditTriangleSublabel = (idx) => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          const current = triangleSublabels[idx] ?? '...';
          editBaseTriSubRef.current = current || '...';
          setTriSubEditVal(current === '...' ? '' : current);
          setEditTriSubIdx(idx);
          onEditStart();
        }
      };

      const handleLabelClick = () => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          editBaseLabelRef.current = val || '...';
          if (val === '...') setVal('');
          setEditLabel(true);
          onEditStart();
        }
      };

      const handleTriClick = () => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          editBaseTriRef.current = tVal || '...';
          if (tVal === '...') setTVal('');
          setEditTri(true);
          onEditStart();
        }
      };

      const startEditSublabel = (idx) => {
        if (isMoveMode) onNodeClick(node.id);
        else if (isPhaseMode) onPhaseClick(node.id);
        else {
          const current = sublabels[idx] ?? '...';
          editBaseSubRef.current = current || '...';
          setSubEditVal(current === '...' ? '' : current);
          setEditSubIdx(idx);
          onEditStart();
        }
      };

      const triangleWidth = node.triangleText !== null
        ? Math.max(80, measureText(node.triangleText || '...') + 40)
        : 80;

      return (
        <div className="tree-node" data-node-id={node.id} data-has-sublabel={hasSublabels}>
          <div className={`node-wrapper ${hasSublabels ? 'has-sublabels' : ''}`}>
            <div className={`node-content ${hasSublabels ? 'has-sublabels' : ''} ${buildMode === 'bottomup' ? 'bottomup' : ''}`}>
              <div className={`node-label ${isSpecialMode ? 'move-mode' : ''} ${editLabel ? 'is-editing' : ''}`}>
                {/* Keep display in-flow to stabilize layout; place the input as an overlay */}
                <div
                  className={`node-display ${isSpecialMode ? 'move-active' : ''} ${sourceId === node.id ? 'is-source' : ''} ${(editLabel ? editBaseLabelRef.current : val) === '...' ? 'placeholder' : ''}`}
                  onClick={handleLabelClick}
                  dangerouslySetInnerHTML={{ __html: formatLabel(editLabel ? editBaseLabelRef.current : val) || '...' }}
                />
                {editLabel && (
                  <input
                    className="label-input-overlay"
                    autoFocus
                    value={val}
                    onChange={e => setVal(e.target.value)}
                    onBlur={() => { updateNode(node.id, { label: val || '...' }); setEditLabel(false); onEditEnd(); }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') e.currentTarget.blur();
                      if (e.key === 'Escape') { setVal(node.label); setEditLabel(false); onEditEnd(); }
                    }}
                  />
                )}
              </div>

              {hasSublabels && (
                <div className="node-sublabels">
                  {sublabels.map((s, idx) => (
                    <div className="sublabel-pill" key={`${node.id}-sub-${idx}`}>
                      {/* Keep display in-flow to stabilize layout; place the input as an overlay */}
                      <div
                        className={`node-display ${(editSubIdx === idx ? editBaseSubRef.current : s) === '...' ? 'placeholder' : ''}`}
                        onClick={() => startEditSublabel(idx)}
                        dangerouslySetInnerHTML={{ __html: formatLabel(editSubIdx === idx ? editBaseSubRef.current : s) || '...' }}
                      />
                      {editSubIdx === idx && (
                        <input
                          className="sublabel-input-overlay"
                          autoFocus
                          value={subEditVal}
                          onChange={e => setSubEditVal(e.target.value)}
                          onBlur={() => {
                            updateSublabel(node.id, idx, subEditVal || '...');
                            setEditSubIdx(null);
                            setSubEditVal('');
                            onEditEnd();
                          }}
                          onKeyDown={e => {
                            if (e.key === 'Enter') e.currentTarget.blur();
                            if (e.key === 'Escape') { setEditSubIdx(null); setSubEditVal(''); onEditEnd(); }
                          }}
                        />
                      )}
                      {!isSpecialMode && (
                        <button className="pill-x" title="Remove this secondary label" onClick={(e) => { e.stopPropagation(); removeSublabel(node.id, idx); }}>×</button>
                      )}
                    </div>
                  ))}
                </div>
              )}

              {!isSpecialMode && (
                <div className="node-actions">
                  {(buildMode === 'bottomup' || (!node.children && !node.triangleText && !node.terminalLocked)) && (
                    <>
                      <button className="action-btn" onClick={() => { if (buildMode === 'bottomup') addParent(node.id, 1); else addNode(node.id, 1); }} title={buildMode === 'bottomup' ? 'Add unary parent' : 'Add single daughter'}>│</button>
                      {buildMode === 'bottomup' ? (
                        <>
                          <button className="action-btn" onClick={() => addParent(node.id, 2, 'right')} title="Add binary parent (sibling to the left)"><span style={{fontSize: '12px'}}>→</span>⑃</button>
                          <button className="action-btn" onClick={() => addParent(node.id, 2, 'left')} title="Add binary parent (sibling to the right)">⑃<span style={{fontSize: '12px'}}>←</span></button>
                        </>
                      ) : (
                        <button className="action-btn" onClick={() => addNode(node.id, 2)} title="Add binary branch">⑃</button>
                      )}
                    </>
                  )}
                  <button className="action-btn" onClick={() => toggleTri(node.id, buildMode)} title={buildMode === 'bottomup' ? 'Add triangle parent' : 'Toggle triangle'}>△</button>
                  <button className={`action-btn ${hasSublabels ? 'active' : ''}`} onClick={() => addSublabel(node.id)} disabled={sublabels.length >= 4} title={sublabels.length >= 4 ? 'Maximum: 4 secondary labels' : 'Add a secondary label (max 4)'}>+₂</button>
                  <button className="action-btn danger" onClick={() => delNode(node.id)} title="Delete node or descendants">✕</button>
                </div>
              )}
            </div>
          </div>

          {node.triangleText !== null && (
            <div className="triangle-container">
              <svg className="triangle-svg" width={triangleWidth} height="50" style={{ overflow: 'visible' }}>
                <polygon points={`${triangleWidth / 2},0 0,50 ${triangleWidth},50`} fill="none" stroke="black" strokeWidth="1.2" />
              </svg>
              <div className={`node-label triangle-label ${hasTriangleSublabels ? 'has-triangle-sublabels' : ''}`}>
                <div
                  className={`node-display ${(editTri ? editBaseTriRef.current : tVal) === '...' ? 'placeholder' : ''}`}
                  onClick={handleTriClick}
                  dangerouslySetInnerHTML={{ __html: formatLabel(editTri ? editBaseTriRef.current : tVal) || '...' }}
                />
                {editTri && (
                  <input
                    className="label-input-overlay"
                    autoFocus
                    value={tVal}
                    onChange={e => setTVal(e.target.value)}
                    onBlur={() => { updateNode(node.id, { triangleText: tVal || '...' }); setEditTri(false); onEditEnd(); }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') e.currentTarget.blur();
                      if (e.key === 'Escape') { setTVal(node.triangleText || ''); setEditTri(false); onEditEnd(); }
                    }}
                  />
                )}
                {hasTriangleSublabels && (
                  <div className="node-sublabels">
                    {triangleSublabels.map((s, idx) => (
                      <div className="sublabel-pill" key={`${node.id}-trisub-${idx}`}>
                        {/* Keep display in-flow to stabilize layout; place the input as an overlay */}
                        <div
                          className={`node-display ${(editTriSubIdx === idx ? editBaseTriSubRef.current : s) === '...' ? 'placeholder' : ''}`}
                          onClick={() => startEditTriangleSublabel(idx)}
                          dangerouslySetInnerHTML={{ __html: formatLabel(editTriSubIdx === idx ? editBaseTriSubRef.current : s) || '...' }}
                        />
                        {editTriSubIdx === idx && (
                          <input
                            className="sublabel-input-overlay"
                            autoFocus
                            value={triSubEditVal}
                            onChange={e => setTriSubEditVal(e.target.value)}
                            onBlur={() => { updateTriangleSublabel(node.id, idx, triSubEditVal || '...'); setEditTriSubIdx(null); setTriSubEditVal(''); onEditEnd(); }}
                            onKeyDown={e => { if (e.key === 'Enter') e.currentTarget.blur(); if (e.key === 'Escape') { setEditTriSubIdx(null); setTriSubEditVal(''); onEditEnd(); } }}
                          />
                        )}
                        {!isSpecialMode && (<button className="pill-x" title="Remove this secondary label" onClick={(e) => { e.stopPropagation(); removeTriangleSublabel(node.id, idx); }}>×</button>)}
                      </div>
                    ))}
                  </div>
                )}
                {!isSpecialMode && (
                  <div className="node-actions">
                    <button className={`action-btn ${hasTriangleSublabels ? 'active' : ''}`} onClick={() => addTriangleSublabel(node.id)} disabled={triangleSublabels.length >= 4} title={triangleSublabels.length >= 4 ? 'Maximum: 4 secondary labels' : 'Add a secondary label (max 4)'}>+₂</button>
                    <button className="action-btn danger" onClick={() => toggleTri(node.id, 'topdown')} title="Remove triangle">✕</button>
                  </div>
                )}
              </div>
            </div>
          )}

          {node.children && (
            <div className="node-children">
              {node.children.map(c => (
                <TreeNode key={c.id} node={c} isRoot={false} {...{updateNode, addNode, addParent, addSublabel, updateSublabel, removeSublabel, addTriangleSublabel, updateTriangleSublabel, removeTriangleSublabel, buildMode, toggleTri, delNode, isMoveMode, isPhaseMode, sourceId, onNodeClick, onPhaseClick, onEditStart, onEditEnd}} />
              ))}
            </div>
          )}
        </div>
      );
    };

    const KilmerApp = () => {
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const isUndoRedo = useRef(false);

      const [tree, setTreeInternal] = useState(null);
      const [moves, setMovesInternal] = useState([]);
      const [phases, setPhasesInternal] = useState(new Set());
      const [dottedLines, setDottedLinesInternal] = useState(new Set());
      const [isMoveMode, setIsMoveMode] = useState(false);
      const [isPhaseMode, setIsPhaseMode] = useState(false);
      const [buildMode, setBuildMode] = useState('topdown');
      const [sourceId, setSourceId] = useState(null);
      const [svgLines, setSvgLines] = useState(null);
      const [showInstructions, setShowInstructions] = useState(false);
      const [zoomLevel, setZoomLevel] = useState(100);
      const [lastSaved, setLastSaved] = useState(null);
      const [isSaving, setIsSaving] = useState(false);
      const isEditingRef = useRef(false);
      const canvasRef = useRef(null);
      const zoomContainerRef = useRef(null);
      const fileRef = useRef(null);

      const [contentSize, setContentSize] = useState({ w: 0, h: 0 });
      const [minCanvas, setMinCanvas] = useState({ w: 0, h: 0 });

      const ZOOM_MIN = 40;
      const ZOOM_MAX = 200;
      const ZOOM_STEP = 20;

      const zoomIn = useCallback(() => { setZoomLevel(prev => Math.min(prev + ZOOM_STEP, ZOOM_MAX)); }, []);
      const zoomOut = useCallback(() => { setZoomLevel(prev => Math.max(prev - ZOOM_STEP, ZOOM_MIN)); }, []);
      const zoomReset = useCallback(() => { setZoomLevel(100); }, []);

      // Auto-save functionality
      const debounce = (func, delay) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), delay);
        };
      };

      const formatTimeAgo = (date) => {
        const seconds = Math.floor((Date.now() - date) / 1000);
        if (seconds < 60) return 'just now';
        const minutes = Math.floor(seconds / 60);
        if (minutes === 1) return '1 minute ago';
        if (minutes < 60) return `${minutes} minutes ago`;
        const hours = Math.floor(minutes / 60);
        if (hours === 1) return '1 hour ago';
        return `${hours} hours ago`;
      };

      const performAutoSave = useCallback(() => {
        if (!tree || isUndoRedo.current) return;
        
        setIsSaving(true);
        const data = {
          tree: tree,
          moves: moves,
          phases: Array.from(phases),
          dottedLines: Array.from(dottedLines),
          timestamp: new Date().toISOString(),
          version: '1.0'
        };
        
        try {
          localStorage.setItem('kilmer-autosave', JSON.stringify(data));
          setLastSaved(new Date());
          setTimeout(() => setIsSaving(false), 500);
        } catch (err) {
          console.error('Error auto-saving:', err);
          setIsSaving(false);
        }
      }, [tree, moves, phases, dottedLines]);

      const autoSaveDebounced = useRef(null);
      if (!autoSaveDebounced.current) {
        autoSaveDebounced.current = debounce((saveFn) => saveFn(), 3000);
      }

// Capture the original canvas size as a minimum (so the canvas can grow and shrink but never below this).
useLayoutEffect(() => {
  const c = canvasRef.current;
  if (!c) return;
  const rect = c.getBoundingClientRect();
  setMinCanvas({ w: Math.ceil(rect.width), h: Math.ceil(rect.height) });
}, []);
// Canvas sizing: grow/shrink with the rendered tree (including zoom), but never below the original canvas size.
const PAD_X = 120; // extra horizontal breathing room inside the scroll stage
const PAD_Y = 80;  // extra vertical breathing room inside the scroll stage
const minW = minCanvas.w || 900;
const minH = minCanvas.h || 267;
const stageW = Math.max(minW, (contentSize.w || 0) + PAD_X);
const stageH = Math.max(minH, (contentSize.h || 0) + PAD_Y);

// SVG needs a real (UNSCALED) box size for reliable PNG export (html2canvas can clip if it's too small).
// We compute it from the scaled bounds by dividing by zoom.
const zoomScaleForSvg = Math.max(0.01, zoomLevel / 100);
const svgPadX = 240;
const svgPadY = 250; // Moderate padding for arrows
const svgW = Math.max(1, Math.ceil(((contentSize.w || 0) / zoomScaleForSvg) + svgPadX));
const svgH = Math.max(1, Math.ceil(((contentSize.h || 0) / zoomScaleForSvg) + svgPadY));

      const createSnapshot = useCallback(() => ({
        tree: tree ? JSON.parse(JSON.stringify(tree)) : null,
        moves: JSON.parse(JSON.stringify(moves)),
        phases: Array.from(phases),
        dottedLines: Array.from(dottedLines)
      }), [tree, moves, phases, dottedLines]);

      const restoreSnapshot = useCallback((snapshot) => {
        isUndoRedo.current = true;
        setTreeInternal(snapshot.tree);
        setMovesInternal(snapshot.moves);
        setPhasesInternal(new Set(snapshot.phases || []));
        setDottedLinesInternal(new Set(snapshot.dottedLines));
        setTimeout(() => { isUndoRedo.current = false; }, 0);
      }, []);

      const pushHistory = useCallback(() => {
        if (isUndoRedo.current) return;
        const snapshot = createSnapshot();
        setHistory(prev => {
          const newHistory = prev.slice(0, historyIndex + 1);
          newHistory.push(snapshot);
          if (newHistory.length > 50) newHistory.shift();
          return newHistory;
        });
        setHistoryIndex(prev => Math.min(prev + 1, 49));
      }, [createSnapshot, historyIndex]);

      const setTree = useCallback((updater) => { setTreeInternal(prev => typeof updater === 'function' ? updater(prev) : updater); }, []);
      const setMoves = useCallback((updater) => { setMovesInternal(prev => typeof updater === 'function' ? updater(prev) : updater); }, []);
      const setDottedLines = useCallback((updater) => { setDottedLinesInternal(prev => typeof updater === 'function' ? updater(prev) : updater); }, []);
      const setPhases = useCallback((updater) => { setPhasesInternal(prev => typeof updater === 'function' ? updater(prev) : updater); }, []);

      const togglePhase = useCallback((nodeId) => {
        setPhases(prev => {
          const newSet = new Set(prev);
          if (newSet.has(nodeId)) newSet.delete(nodeId);
          else newSet.add(nodeId);
          return newSet;
        });
      }, []);

      useEffect(() => {
        if (!isUndoRedo.current && tree !== null) {
          const timeoutId = setTimeout(pushHistory, 100);
          return () => clearTimeout(timeoutId);
        }
      }, [tree, moves, phases, dottedLines]);

      // Auto-save effect: save when tree/moves/phases/dottedLines change
      useEffect(() => {
        if (tree && !isUndoRedo.current) {
          autoSaveDebounced.current(performAutoSave);
        }
      }, [tree, moves, phases, dottedLines, performAutoSave]);

      // Restore from auto-save on mount
      useEffect(() => {
        const saved = localStorage.getItem('kilmer-autosave');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            const savedDate = new Date(data.timestamp);
            const minutesAgo = Math.round((Date.now() - savedDate) / 60000);
            
            const message = minutesAgo < 1 
              ? 'Found recent unsaved work.\n\nContinue where you left off?'
              : `Found unsaved work from ${minutesAgo} minute${minutesAgo === 1 ? '' : 's'} ago.\n\nContinue where you left off?`;
            
            const restore = confirm(message);
            
            if (restore) {
              isUndoRedo.current = true;
              setTreeInternal(normalizeNode(data.tree));
              setMovesInternal(data.moves || []);
              setPhasesInternal(new Set(data.phases || []));
              setDottedLinesInternal(new Set(data.dottedLines || []));
              setHistory([]);
              setHistoryIndex(-1);
              setTimeout(() => { isUndoRedo.current = false; }, 0);
            } else {
              localStorage.removeItem('kilmer-autosave');
            }
          } catch (err) {
            console.error('Error restoring auto-save:', err);
            localStorage.removeItem('kilmer-autosave');
          }
        }
      }, []); // Solo al montar

      const undo = useCallback(() => {
        if (historyIndex > 0) {
          const newIndex = historyIndex - 1;
          setHistoryIndex(newIndex);
          restoreSnapshot(history[newIndex]);
        }
      }, [history, historyIndex, restoreSnapshot]);

      const redo = useCallback(() => {
        if (historyIndex < history.length - 1) {
          const newIndex = historyIndex + 1;
          setHistoryIndex(newIndex);
          restoreSnapshot(history[newIndex]);
        }
      }, [history, historyIndex, restoreSnapshot]);

      const canUndo = historyIndex > 0;
      const canRedo = historyIndex < history.length - 1;

      const saveTree = useCallback(() => {
        if (!tree) return;
        const filename = (prompt('Enter filename:', 'tree') || 'tree').replace(/\s+/g, '_');
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([JSON.stringify({tree, moves, phases: Array.from(phases), dottedLines: Array.from(dottedLines)})], {type:'application/json'}));
        a.download = `${filename}.kilmer`;
        a.click();
        
        // Limpiar auto-guardado después de guardar manualmente
        localStorage.removeItem('kilmer-autosave');
        setLastSaved(null);
      }, [tree, moves, phases, dottedLines]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
          if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey) || (e.key === 'Z' && e.shiftKey))) { e.preventDefault(); redo(); }
          if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); saveTree(); }
          if (e.key === 'Escape') {
            if (isMoveMode) { setIsMoveMode(false); setSourceId(null); }
            if (isPhaseMode) { setIsPhaseMode(false); }
          }
          if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '=')) { e.preventDefault(); zoomIn(); }
          if ((e.ctrlKey || e.metaKey) && e.key === '-') { e.preventDefault(); zoomOut(); }
          if ((e.ctrlKey || e.metaKey) && e.key === '0') { e.preventDefault(); zoomReset(); }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [undo, redo, saveTree, isMoveMode, isPhaseMode, zoomIn, zoomOut, zoomReset]);

      const toggleDottedLine = (lineKey) => {
        setDottedLines(prev => {
          const newSet = new Set(prev);
          if (newSet.has(lineKey)) newSet.delete(lineKey);
          else newSet.add(lineKey);
          return newSet;
        });
      };

      const findAndUpdate = (n, id, update) => {
        if (!n) return null;
        if (n.id === id) return { ...n, ...update };
        return { ...n, children: n.children ? n.children.map(c => findAndUpdate(c, id, update)) : null };
      };

      const findAndRemove = (n, id) => {
        if (!n || !n.children) return n;
        if (n.children.some(c => c.id === id)) {
          return { ...n, children: n.children.filter(c => c.id !== id).length > 0 ? n.children.filter(c => c.id !== id) : null };
        }
        return { ...n, children: n.children.map(c => findAndRemove(c, id)) };
      };

      const makeBlankNode = () => ({ id: generateId(), label: '...', children: null, triangleText: null, triangleSublabels: [], sublabels: [], terminalLocked: false });

      const normalizeNode = (n) => {
        if (!n) return null;
        const sublabels = Array.isArray(n.sublabels) ? n.sublabels.slice(0, 4) : (n.sublabel !== null && n.sublabel !== undefined ? [n.sublabel] : []);
        const triangleSublabels = Array.isArray(n.triangleSublabels) ? n.triangleSublabels.slice(0, 4) : [];
        const locked = !!n.terminalLocked || sublabels.length >= 2;
        return {
          id: n.id || generateId(),
          label: n.label !== undefined && n.label !== null ? n.label : '...',
          children: n.children ? n.children.map(normalizeNode) : null,
          triangleText: (n.triangleText !== undefined ? n.triangleText : null),
          triangleSublabels, sublabels, terminalLocked: locked
        };
      };

      const updateNode = (id, up) => setTree(prev => findAndUpdate(prev, id, up));

      const addNode = (id, count) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            if (n.terminalLocked) return n;
            return { ...n, children: Array.from({ length: count }, makeBlankNode) };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const addParent = (id, arity, side = 'left') => {
        const wrapWithParent = (child) => {
          const parent = makeBlankNode();
          if (arity === 1) { parent.children = [child]; }
          else {
            const sibling = makeBlankNode();
            parent.children = side === 'right' ? [sibling, child] : [child, sibling];
          }
          return parent;
        };
        const rec = (n) => {
          if (!n) return [n, false];
          if (n.id === id) return [wrapWithParent(n), true];
          if (!n.children) return [n, false];
          let changed = false;
          const newChildren = n.children.map(c => {
            const [nextChild, didChange] = rec(c);
            changed = changed || didChange;
            return nextChild;
          });
          if (!changed) return [n, false];
          return [{ ...n, children: newChildren }, true];
        };
        setTree(prev => { const [next, changed] = rec(prev); return changed ? next : prev; });
      };

      const delNode = (id) => {
        if (tree.id === id) { setTree(prev => ({...prev, children: null, triangleText: null, sublabels: [], terminalLocked: false})); }
        else { setTree(prev => findAndRemove(prev, id)); }
        setMoves(prev => prev.filter(m => m.from !== id && m.to !== id));
      };

      const toggleTri = (id, mode = 'topdown') => {
        if (mode === 'bottomup') {
          const wrapWithTriangleParent = (child) => {
            const parent = makeBlankNode();
            parent.triangleText = child.label !== '...' ? child.label : '...';
            parent.children = null;
            return parent;
          };
          const rec = (n) => {
            if (!n) return [n, false];
            if (n.id === id) {
              if (n.triangleText !== null) return [{ ...n, triangleText: null }, true];
              return [wrapWithTriangleParent(n), true];
            }
            if (!n.children) return [n, false];
            let changed = false;
            const newChildren = n.children.map(c => { const [nextChild, didChange] = rec(c); changed = changed || didChange; return nextChild; });
            if (!changed) return [n, false];
            return [{ ...n, children: newChildren }, true];
          };
          setTree(prev => {
            if (prev.id === id) {
              if (prev.triangleText !== null) return { ...prev, triangleText: null };
              return wrapWithTriangleParent(prev);
            }
            const [next, changed] = rec(prev);
            return changed ? next : prev;
          });
        } else {
          const rec = (n) => {
            if (!n) return null;
            if (n.id === id) return n.triangleText !== null ? { ...n, triangleText: null } : { ...n, triangleText: '...', children: null };
            return { ...n, children: n.children ? n.children.map(rec) : null };
          };
          setTree(prev => rec(prev));
        }
      };

      const addSublabel = (id) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            if (current.length >= 4) return n;
            const nextSublabels = [...current, '...'];
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;
            return { ...n, sublabels: nextSublabels, terminalLocked: nextLocked, children: nextLocked ? null : n.children };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const updateSublabel = (id, idx, value) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            const nextSublabels = current.map((s, i) => (i === idx ? (value || '...') : s));
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;
            return { ...n, sublabels: nextSublabels, terminalLocked: nextLocked, children: nextLocked ? null : n.children };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const removeSublabel = (id, idx) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.sublabels) ? n.sublabels : [];
            const nextSublabels = current.filter((_, i) => i !== idx);
            const nextLocked = n.terminalLocked || nextSublabels.length >= 2;
            return { ...n, sublabels: nextSublabels, terminalLocked: nextLocked, children: nextLocked ? null : n.children };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const addTriangleSublabel = (id) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            if (current.length >= 4) return n;
            return { ...n, triangleSublabels: [...current, '...'] };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const updateTriangleSublabel = (id, idx, value) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            return { ...n, triangleSublabels: current.map((s, i) => (i === idx ? (value || '...') : s)) };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      const removeTriangleSublabel = (id, idx) => {
        const rec = (n) => {
          if (!n) return null;
          if (n.id === id) {
            const current = Array.isArray(n.triangleSublabels) ? n.triangleSublabels : [];
            return { ...n, triangleSublabels: current.filter((_, i) => i !== idx) };
          }
          return { ...n, children: n.children ? n.children.map(rec) : null };
        };
        setTree(prev => rec(prev));
      };

      // Edit state management - prevents line jumping during editing
      const onEditStart = useCallback(() => { isEditingRef.current = true; }, []);
      const onEditEnd = useCallback(() => {
        isEditingRef.current = false;
        // Redraw after editing ends
        setTimeout(() => draw(), 0);
      }, [draw]);

      const draw = useCallback(() => {
        if (!zoomContainerRef.current || !tree) return;
        if (isEditingRef.current) return; // Don't redraw while editing
        const container = zoomContainerRef.current;
        const rect = container.getBoundingClientRect();
        const zoomScale = zoomLevel / 100;

        const getPos = (id) => {
          const nodeEl = container.querySelector(`[data-node-id="${id}"]`);
          if (!nodeEl) return null;

          const hasSublabel = nodeEl.getAttribute('data-has-sublabel') === 'true';
          const hasTriangle = nodeEl.querySelector(':scope > .triangle-container') !== null;

          let bottomEl;
          if (hasTriangle) {
            // For triangle: prefer .node-display, fallback to input if editing
            bottomEl = nodeEl.querySelector(':scope > .triangle-container > .node-label .node-display')
                    || nodeEl.querySelector(':scope > .triangle-container > .node-label input');
          } else if (hasSublabel) {
            const subs = nodeEl.querySelectorAll(':scope > .node-wrapper .node-sublabels .node-display');
            const subInputs = nodeEl.querySelectorAll(':scope > .node-wrapper .node-sublabels input');
            // Use last visible element (display or input)
            bottomEl = subs && subs.length ? subs[subs.length - 1] : (subInputs && subInputs.length ? subInputs[subInputs.length - 1] : null);
          } else {
            bottomEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display')
                    || nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label input');
          }

          // For top element: prefer .node-display, fallback to input if editing
          const topEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display')
                     || nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label input');
          if (!bottomEl || !topEl) return null;

          const bottomR = bottomEl.getBoundingClientRect();
          const topR = topEl.getBoundingClientRect();

          return {
            x: (topR.left + topR.width/2 - rect.left) / zoomScale,
            y: (topR.top - rect.top) / zoomScale,
            topR: { top: (topR.top - rect.top) / zoomScale, bottom: (topR.bottom - rect.top) / zoomScale },
            bottomR: { top: (bottomR.top - rect.top) / zoomScale, bottom: (bottomR.bottom - rect.top) / zoomScale },
            hasSublabel, hasTriangle
          };
        };

        const lines = [];
        const allNodes = container.querySelectorAll('[data-node-id]');
        allNodes.forEach(nodeEl => {
          const id = nodeEl.getAttribute('data-node-id');
          const pPos = getPos(id);
          if (!pPos) return;
          const childCont = nodeEl.querySelector(':scope > .node-children');
          if (childCont) {
            childCont.querySelectorAll(':scope > .tree-node').forEach(childEl => {
              const cId = childEl.getAttribute('data-node-id');
              const cPos = getPos(cId);
              if (cPos) {
                const startY = pPos.bottomR.bottom;
                const endY = cPos.topR.top;
                const lineKey = `${id}-${cId}`;
                const isDotted = dottedLines.has(lineKey);
                lines.push(
                  <g key={lineKey} style={{cursor: 'pointer'}} onDoubleClick={(e) => { e.preventDefault(); e.stopPropagation(); toggleDottedLine(lineKey); }}>
                    <line x1={pPos.x} y1={startY} x2={cPos.x} y2={endY} stroke="transparent" strokeWidth="15" style={{pointerEvents: 'stroke'}} />
                    <line x1={pPos.x} y1={startY} x2={cPos.x} y2={endY} stroke="black" strokeWidth="1.2" strokeDasharray={isDotted ? "5,4" : "none"} style={{pointerEvents: 'none'}} />
                  </g>
                );
              }
            });
          }
        });

        const arrows = moves.map(m => {
          const s = getPos(m.from); const e = getPos(m.to);
          if (!s || !e) return null;
          const midX = (s.x + e.x) / 2;
          const curve = Math.max(70, Math.abs(e.x - s.x)/2.2);
          const ctrlY = Math.max(s.bottomR.bottom, e.bottomR.bottom) + curve;
          const sy = s.bottomR.bottom; const ey = e.bottomR.bottom;
          const path = `M ${s.x} ${sy} Q ${midX} ${ctrlY} ${e.x} ${ey}`;
          const t = 0.5;
          const bx = (1-t)**2 * s.x + 2*(1-t)*t*midX + t**2 * e.x;
          const by = (1-t)**2 * sy + 2*(1-t)*t*ctrlY + t**2 * ey;
          const arrowKey = `arrow-${m.id}`;
          const isDotted = dottedLines.has(arrowKey);
          return (
            <g key={m.id} className="arrow-group">
              <path d={path} fill="none" stroke="transparent" strokeWidth="15" style={{cursor: 'pointer', pointerEvents: 'stroke'}} onDoubleClick={(e) => { e.preventDefault(); e.stopPropagation(); toggleDottedLine(arrowKey); }} />
              <path d={path} fill="none" stroke="black" strokeWidth="1.5" markerEnd="url(#head)" opacity="0.8" strokeDasharray={isDotted ? "5,4" : "none"} style={{pointerEvents: 'none'}} />
              <g className="arrow-delete-btn" onClick={() => setMoves(prev => prev.filter(x => x.id !== m.id))} transform={`translate(${bx-10},${by-10})`}>
                <rect width="20" height="20" fill="white" stroke="#e0ddd8" /><text x="10" y="15" textAnchor="middle" fontSize="14" fill="#dc2626">×</text>
              </g>
            </g>
          );
        });

        const phaseArcs = Array.from(phases).map(nodeId => {
          const nodeEl = container.querySelector(`[data-node-id="${nodeId}"]`);
          if (!nodeEl) return null;
          const labelEl = nodeEl.querySelector(':scope > .node-wrapper .node-content > .node-label .node-display');
          if (!labelEl) return null;

          const labelRect = labelEl.getBoundingClientRect();
          const x = (labelRect.left - rect.left) / zoomScale;
          const y = (labelRect.top - rect.top) / zoomScale;
          const width = labelRect.width / zoomScale;

          const padding = 14;
          const arcHeight = 15;
          const startX = x - padding;
          const startY = y + 5;
          const endX = x + width + padding;
          const endY = y + 5;
          const controlY = y - arcHeight;

          const path = `M ${startX} ${startY} Q ${x + width/2} ${controlY} ${endX} ${endY}`;
          const phaseKey = `phase-${nodeId}`;
          const isDotted = !dottedLines.has(phaseKey);

          return (
            <g key={phaseKey} className="phase-group">
              <path d={path} fill="none" stroke="transparent" strokeWidth="12" style={{cursor: 'pointer', pointerEvents: 'stroke'}} onDoubleClick={(e) => { e.preventDefault(); e.stopPropagation(); toggleDottedLine(phaseKey); }} />
              <path d={path} fill="none" stroke="black" strokeWidth="1.5" strokeDasharray={isDotted ? "5,3" : "none"} opacity="0.8" style={{pointerEvents: 'none'}} />
              <g className="arrow-delete-btn" onClick={() => togglePhase(nodeId)} transform={`translate(${x + width/2 - 10},${controlY - 18})`}>
                <rect width="20" height="20" fill="white" stroke="#e0ddd8" /><text x="10" y="15" textAnchor="middle" fontSize="14" fill="#dc2626">×</text>
              </g>
            </g>
          );
        });

        // --- Measure rendered tree bounds (in container coords) to size the scroll stage correctly ---
        try {
          let minLeft = Infinity, minTop = Infinity, maxRight = -Infinity, maxBottom = -Infinity;

          const nodesForBounds = container.querySelectorAll('[data-node-id]');
          nodesForBounds.forEach(nodeEl => {
            const wrapper = nodeEl.querySelector(':scope > .node-wrapper');
            if (wrapper) {
              const r = wrapper.getBoundingClientRect();
              minLeft = Math.min(minLeft, r.left);
              minTop = Math.min(minTop, r.top);
              maxRight = Math.max(maxRight, r.right);
              maxBottom = Math.max(maxBottom, r.bottom);
            }
            const tri = nodeEl.querySelector(':scope > .triangle-container');
            if (tri) {
              const tr = tri.getBoundingClientRect();
              minLeft = Math.min(minLeft, tr.left);
              minTop = Math.min(minTop, tr.top);
              maxRight = Math.max(maxRight, tr.right);
              maxBottom = Math.max(maxBottom, tr.bottom);
            }
          });

          if (minLeft !== Infinity) {
            const wScaled = Math.max(0, Math.ceil((maxRight - minLeft)));  // already includes zoom because rects are in CSS pixels
            const hScaled = Math.max(0, Math.ceil((maxBottom - minTop)));
            setContentSize({ w: wScaled, h: hScaled });
          } else {
            setContentSize({ w: 0, h: 0 });
          }
        } catch (err) {
          // In case of any DOM measurement issue, don't block rendering
        }
        // --- End bounds measurement ---

        setSvgLines(<><defs><marker id="head" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="black" /></marker></defs>{lines}{arrows}{phaseArcs}</>);
      }, [tree, moves, phases, dottedLines, zoomLevel]);

      useLayoutEffect(() => { draw(); }, [tree, moves, phases, dottedLines, zoomLevel, draw]);
      useEffect(() => { window.addEventListener('resize', draw); return () => window.removeEventListener('resize', draw); }, [draw]);

      const load = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          try {
            const data = JSON.parse(ev.target.result);
            isUndoRedo.current = true;
            setTreeInternal(normalizeNode(data.tree || data));
            setMovesInternal(data.moves || []);
            setPhasesInternal(new Set(data.phases || []));
            setDottedLinesInternal(new Set(data.dottedLines || []));
            setHistory([]);
            setHistoryIndex(-1);
            localStorage.removeItem('kilmer-autosave');
            setLastSaved(null);
            setTimeout(() => { isUndoRedo.current = false; }, 0);
          } catch(err) { alert("Invalid JSON file"); }
        };
        reader.readAsText(file);
        e.target.value = "";
      };

      return (
        <div className="container">
          <header className="header">
            <img src={LOGO_URL} alt="Kilmer" className="header-logo" onError={e => e.target.style.display='none'} />
          </header>

          <div className="toolbar">
            <button className="btn btn-primary" onClick={() => {setTree({id: generateId(), label: '...', children: null, triangleText: null, sublabels: [], terminalLocked: false}); setMoves([]); setPhases(new Set()); setDottedLines(new Set()); setHistory([]); setHistoryIndex(-1); localStorage.removeItem('kilmer-autosave'); setLastSaved(null);}}>New Tree</button>
            <div className="toolbar-divider" />
            <button className="btn" onClick={() => fileRef.current.click()}>Load .kilmer</button>
            <input type="file" ref={fileRef} style={{display:'none'}} accept=".kilmer,.json,application/json,text/plain,*/*" onChange={load} />
            <button className="btn" onClick={saveTree} disabled={!tree} title="Save (Ctrl+S)">Save .kilmer</button>
            <button className="btn" onClick={async () => {
              const filename = (prompt('Enter filename:', 'syntax_tree') || 'syntax_tree').replace(/\s+/g, '_');
              if (!filename) return;

              const savedZoom = zoomLevel;
              setZoomLevel(100);

              await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
              await new Promise(resolve => setTimeout(resolve, 100));

              const el = zoomContainerRef.current;
              if (!el) { setZoomLevel(savedZoom); return; }

              const copyComputedStyles = (source, target, skipBorderStyles = false) => {
                const computed = window.getComputedStyle(source);
                for (let i = 0; i < computed.length; i++) {
                  const prop = computed[i];
                  if (skipBorderStyles && (prop.startsWith('border') || prop === 'box-shadow' || prop === 'outline')) continue;
                  target.style.setProperty(prop, computed.getPropertyValue(prop));
                }
              };

              const cloneWithStyles = (element) => {
                const clone = element.cloneNode(false);
                const isPill = element.classList && element.classList.contains('sublabel-pill');
                copyComputedStyles(element, clone, isPill);
                for (let child of element.childNodes) {
                  if (child.nodeType === Node.ELEMENT_NODE) clone.appendChild(cloneWithStyles(child));
                  else clone.appendChild(child.cloneNode(true));
                }
                return clone;
              };

              const clone = cloneWithStyles(el);
              setZoomLevel(savedZoom);

              // --- Evita colisión de IDs de markers SVG (previene pérdida de punta tras exportar) ---
              const exportMarkerId = `head_export_${Date.now()}`;

              // Renombra el marker en el CLON (si existe)
              clone.querySelectorAll('marker#head').forEach(m => { m.id = exportMarkerId; });

              // Actualiza cualquier referencia marker-end en el CLON
              clone.querySelectorAll('[marker-end="url(#head)"]').forEach(p => {
                p.setAttribute('marker-end', `url(#${exportMarkerId})`);
              });

              clone.querySelectorAll('.node-actions, .arrow-delete-btn').forEach(x => x.remove());
              clone.querySelectorAll('.pill-x').forEach(x => x.remove());
              clone.querySelectorAll('.sublabel-pill').forEach(pill => {
                pill.style.border = 'none'; pill.style.borderWidth = '0'; pill.style.borderStyle = 'none';
                pill.style.borderRadius = '0'; pill.style.background = 'transparent';
                pill.style.backgroundColor = 'transparent'; pill.style.padding = '0';
                pill.style.boxShadow = 'none'; pill.style.outline = 'none';
                pill.style.display = 'flex'; pill.style.alignItems = 'center'; pill.style.justifyContent = 'center';
              });
              clone.style.transform = 'none';
              clone.style.margin = '20px';

              // Force explicit height on clone to include all content including arrows
              const svgEl = clone.querySelector('svg');
              if (svgEl) {
                const svgHeight = parseInt(svgEl.getAttribute('height'));
                clone.style.minHeight = (svgHeight - 175) + 'px'; // Reduce bottom margin in export
              }

              const container = document.createElement('div');
              container.style.cssText = 'position: fixed; left: 0; top: 0; z-index: -9999; pointer-events: none; overflow: visible; background: transparent; padding: 0;';
              container.appendChild(clone);
              document.body.appendChild(container);

              await new Promise(resolve => setTimeout(resolve, 150));

              try {
                const pad = 40; // margen de seguridad alrededor

          const containerRect = container.getBoundingClientRect();

          // calcula el bbox real de TODO lo visible dentro del clone (sin contar el SVG "lienzo" gigante)
          let minL = Infinity, minT = Infinity, maxR = -Infinity, maxB = -Infinity;

          // incluye el propio clone + todos sus descendientes
          const elems = [clone, ...clone.querySelectorAll('*')];

          for (const e of elems) {
            // OJO: el SVG principal de líneas suele ser enorme (width/height del stage) y mete espacio en blanco.
            // Lo excluimos del bbox, pero mantenemos sus hijos (paths, etc.) que sí tienen bbox real.
            if (e.tagName === 'svg' && e.parentElement && e.parentElement.classList && e.parentElement.classList.contains('zoom-container')) {
              const pos = (e.style && e.style.position) ? e.style.position : '';
              if (pos === 'absolute' && !e.classList.contains('triangle-svg')) continue;
            }

            const r = e.getBoundingClientRect();
            if (!r || (r.width === 0 && r.height === 0)) continue;
            if (r.left < minL) minL = r.left;
            if (r.top < minT) minT = r.top;
            if (r.right > maxR) maxR = r.right;
            if (r.bottom > maxB) maxB = r.bottom;
          }

          // fallback por si algo raro ocurre
          if (!isFinite(minL) || !isFinite(minT) || !isFinite(maxR) || !isFinite(maxB)) {
            const r = clone.getBoundingClientRect();
            minL = r.left; minT = r.top; maxR = r.right; maxB = r.bottom;
          }

          // convierte bbox “de viewport” a coordenadas relativas al container para html2canvas
          const x = (minL - containerRect.left) - pad;
          const y = (minT - containerRect.top) - pad;
          const width = (maxR - minL) + (pad * 2);
          const height = (maxB - minT) + (pad * 2);

          const cv = await html2canvas(container, {
            backgroundColor: null,
            scale: 3,
            useCORS: true,
            logging: false,
            x,
            y,
            width,
            height
          });
                const a = document.createElement('a');
                a.download = `${filename}.png`;
                a.href = cv.toDataURL('image/png');
                a.click();
              } finally { document.body.removeChild(container); }
            }} disabled={!tree}>Export PNG</button>

            <div className="toolbar-divider" />
            <div className="segmented-control" title="Build direction">
              <button className={buildMode === 'topdown' ? 'active' : ''} onClick={() => setBuildMode('topdown')}>Top-down</button>
              <button className={buildMode === 'bottomup' ? 'active' : ''} onClick={() => setBuildMode('bottomup')}>Bottom-up</button>
            </div>

            <div className="toolbar-divider" />
            <button className={`btn ${isMoveMode ? 'active-mode' : ''}`} onClick={() => {setIsMoveMode(!isMoveMode); setIsPhaseMode(false); setSourceId(null);}} disabled={!tree}>
              Move
            </button>
            <button className={`btn ${isPhaseMode ? 'active-mode' : ''}`} onClick={() => {setIsPhaseMode(!isPhaseMode); setIsMoveMode(false); setSourceId(null);}} disabled={!tree}>
              Phase
            </button>

            <div className="toolbar-divider" />
            <button className="btn" onClick={undo} disabled={!canUndo} title="Undo (Ctrl+Z)">↶</button>
            <button className="btn" onClick={redo} disabled={!canRedo} title="Redo (Ctrl+Y)">↷</button>
          </div>

          {/* Mode Status Bar */}
          {isMoveMode && (
            <div className="mode-status-bar">
              <span className="status-icon">⤳</span>
              {sourceId ? (
                <>
                  <span>Click the <strong>target node</strong> to create movement arrow</span>
                  <span className="status-step">Step 2/2</span>
                </>
              ) : (
                <>
                  <span>Click the <strong>source node</strong> (e.g., trace, copy)</span>
                  <span className="status-step">Step 1/2</span>
                </>
              )}
              <button onClick={() => {setIsMoveMode(false); setSourceId(null);}}>Cancel (Esc)</button>
            </div>
          )}
          {isPhaseMode && (
            <div className="mode-status-bar">
              <span className="status-icon">◠</span>
              <span>Click a <strong>phase head</strong> (e.g., vP, CP) to mark phase boundary</span>
              <button onClick={() => setIsPhaseMode(false)}>Cancel (Esc)</button>
            </div>
          )}

          <div className="tree-canvas" ref={canvasRef}>
            <div className={`zoom-controls ${tree ? 'visible' : ''}`}>
              <button className="zoom-btn" onClick={zoomOut} disabled={zoomLevel <= ZOOM_MIN} title="Zoom out (Ctrl/⌘ + −)">−</button>
              <div className="zoom-indicator" onClick={zoomReset} title="Reset zoom (Ctrl/⌘ + 0)">{zoomLevel}%</div>
              <button className="zoom-btn" onClick={zoomIn} disabled={zoomLevel >= ZOOM_MAX} title="Zoom in (Ctrl/⌘ + +)">+</button>
            </div>

            {/* Auto-save indicator - top left corner */}
            <div className={`autosave-indicator ${(isSaving || lastSaved) && tree ? 'visible' : ''}`}>
              {isSaving && (
                <span style={{display: 'flex', alignItems: 'center', gap: '4px'}}>
                  <span style={{animation: 'pulse 1.5s ease-in-out infinite'}}>☁</span> Saving...
                </span>
              )}
              {!isSaving && lastSaved && (
                <span>✓ Auto-saved {formatTimeAgo(lastSaved)}</span>
              )}
            </div>

            <div className="zoom-wrapper" style={{ width: stageW, height: stageH }}>
              <div className="zoom-stage" style={{ width: stageW, height: stageH }}>
              <div className="zoom-container" ref={zoomContainerRef} style={{ transform: `translateX(-50%) scale(${zoomLevel / 100})`, transformOrigin: 'top center' }}>
                <svg width={svgW} height={svgH} style={{position:'absolute', top:0, left:0, pointerEvents:'none', zIndex:1, overflow:'visible'}}>{svgLines}</svg>
                {tree ? <TreeNode node={tree} isRoot={true} {...{updateNode, addNode, addParent, buildMode, toggleTri, addSublabel, updateSublabel, removeSublabel, addTriangleSublabel, updateTriangleSublabel, removeTriangleSublabel, delNode, isMoveMode, isPhaseMode, sourceId, onEditStart, onEditEnd, onNodeClick: (id) => {
                  if (!sourceId) setSourceId(id);
                  else if (sourceId === id) setSourceId(null);
                  else {
                    const newMoveId = generateId();
                    setMoves(p => [...p, {id: newMoveId, from: sourceId, to: id}]);
                    // Make movement arrows dotted by default
                    setDottedLines(prev => {
                      const s = new Set(prev);
                      s.add(`arrow-${newMoveId}`);
                      return s;
                    });
                    setSourceId(null);
                    setIsMoveMode(false);
                  }
                }, onPhaseClick: (id) => { togglePhase(id); setIsPhaseMode(false); }}} /> : <div style={{color:'#999'}}>Click <strong>New Tree</strong> to start a new diagram or <strong>Load .kilmer</strong> to edit a previously saved one</div>}
              </div>
              </div>
            </div>
          </div>

          <div className="instructions-panel">
            <button className="instructions-header" onClick={() => setShowInstructions(prev => !prev)}>
              <span>Instructions</span>
              <span className={`collapse-icon ${showInstructions ? 'expanded' : ''}`}>▶</span>
            </button>
            {showInstructions && (
              <div className="instructions-grid">

              <div className="instruction-card">
                <h4><span className="icon">⑃</span> Building the Tree</h4>
                <ul>
                  <li>Hover over any node to reveal action buttons.</li>
                  <li>Use <code>│</code> for a single daughter or <code>⑃</code> for binary branching.</li>
                  <li>The <code>△</code> button creates a triangle for unanalyzed constituents.</li>
                  <li>Double-click any branch line to toggle dotted style.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">A</span> Editing Labels</h4>
                <ul>
                  <li>Click any label to edit.</li>
                  <li>Confirm with <span className="keyboard-hint"><span class="key">Enter</span></span> or cancel with <span className="keyboard-hint"><span class="key">Esc</span></span> to revert.</li>
                  <li>Use <code>+₂</code> to add a secondary label below the main one.</li>
                </ul>
              </div>

              {/* NEW: Build modes */}
              <div className="instruction-card">
                <h4><span className="icon">⇅</span> Build Modes</h4>
                <ul>
                  <li>Select <strong>Top-down</strong> or <strong>Bottom-up</strong> in the top toolbar to change the construction mode at any time.</li>
                  <li><strong>Top-down</strong>: <code>│</code>, <code>⑃</code>, and <code>△</code> create <strong>daughters</strong> from the selected node.</li>
                  <li><strong>Bottom-up</strong>: <code>│</code>, <code>→⑃</code>/<code>⑃←</code>, and <code>△</code> create a <strong>parent</strong> above the selected node.</li>
                  <li>The arrows in <code>→⑃</code> and <code>⑃←</code> indicate where the <strong>sibling</strong> will appear (left or right).</li>
                  <li>In Bottom-up mode, the node tools appear <strong>above</strong> the node. In Top-down mode, the node tools appear <strong>below</strong>.</li>
                </ul>
              </div>

              {/* NEW: Multiple bottom labels (secondary labels) */}
              <div className="instruction-card">
                <h4><span className="icon">+₂</span> Multiple Bottom Labels</h4>
                <ul>
                  <li>Use <code>+₂</code> to add up to <strong>4</strong> bottom labels (“pills”) under a node.</li>
                  <li>Each secondary label is <strong>editable</strong> (click to edit) and can be removed with its <code>×</code> (visible on hover).</li>
                  <li>If a node reaches <strong>2+</strong> bottom labels, it becomes <strong>terminal (locked)</strong>:
                  existing daughters (if any) are removed, and no new daughters can be added in Top-down mode.</li>
                  <li>Bottom-up wrapping still works on locked nodes (it adds a parent, not daughters).</li>
                </ul>
              </div>

              <div className="instruction-card text-formatting-card">
                <h4><span className="icon">✦</span> Text Formatting</h4>
                <div className="formatting-columns">
                  <ul>
                    <li><code>**text**</code> <span class="example"><span class="arrow">→</span> <span class="result"><b>bold</b></span></span></li>
                    <li><code>*text*</code> <span class="example"><span class="arrow">→</span> <span class="result"><i>italics</i></span></span></li>
                    <li><code>X_i</code> or <code>X_i_</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sub>i</sub></span></span></li>
                    <li><code>X¨n</code> or <code>X¨n¨</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sup>n</sup></span></span></li>
                    <li><code>#X#</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="overline">X</span></span></span></li>
                    <li><code>##X##</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="double-overline">X</span></span></span></li>
                    <li><code>=X=</code> <span class="example"><span class="arrow">→</span> <span class="result"><s>X</s></span></span></li>
                  </ul>
                  <ul>
                    <li className="combining-header">Styles can be combined:</li>
                    <li><code>**X**_i_</code> <span class="example"><span class="arrow">→</span> <span class="result"><b>X</b><sub>i</sub></span></span></li>
                    <li><code>*X*_i_</code> <span class="example"><span class="arrow">→</span> <span class="result"><i>X</i><sub>i</sub></span></span></li>
                    <li><code>X¨*n*¨</code> <span class="example"><span class="arrow">→</span> <span class="result">X<sup><i>n</i></sup></span></span></li>
                    <li><code>#*XP*#</code> <span class="example"><span class="arrow">→</span> <span class="result"><span class="overline"><i>XP</i></span></span></span></li>
                    <li><code>=*t*_i_=</code> <span class="example"><span class="arrow">→</span> <span class="result"><s><i>t</i><sub>i</sub></s></span></span></li>
                  </ul>
                </div>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">⤳</span> Movement Arrows</h4>
                <ul>
                  <li>Activate <strong>Move</strong>, then click the source node (e.g., a trace) followed by the target.</li>
                  <li>Arrows curve beneath the tree.</li>
                  <li>Double-click on the line to toggle dotted style.</li>
                  <li>Click <code>×</code> on any arrow to remove it.</li>
                  <li>Arrows can also represent Agree relations or other long-distance dependencies.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">◠</span> Phase Boundaries</h4>
                <ul>
                  <li>Activate <strong>Phase</strong>, then click a phase head (vP, CP).</li>
                  <li>A dashed arc marks the phase boundary. Double-click to make it solid.</li>
                  <li>Click <code>×</code> on the arc to remove it.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">✕</span> Deleting Nodes</h4>
                <ul>
                  <li>The red <code>✕</code> removes a node and all its descendants.</li>
                  <li>On the root node, it clears the entire structure while preserving the root label.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">◰</span> Saving Your Work</h4>
                <ul>
                  <li><strong>Save</strong> exports a <code>.kilmer</code> file for later editing.</li>
                  <li><strong>Export PNG</strong> generates a clean image for documents and presentations.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">⌕</span> Zoom Controls</h4>
                <ul>
                  <li>Use the <code>[−]</code> and <code>[+]</code> buttons in the top-right corner to zoom in/out.</li>
                  <li>Click the percentage indicator to reset to 100%.</li>
                  <li>Zoom range: 40% to 200% in 20% increments.</li>
                  <li>Controls appear when a tree is present.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">☁</span> Auto-save</h4>
                <ul>
                  <li>Kilmer automatically saves your work every 3 seconds after making changes.</li>
                  <li>If you accidentally close your browser, your work will be protected.</li>
                  <li>When you reopen Kilmer, you'll see a dialog asking if you want to continue where you left off.</li>
                  <li>The indicator in the top-left corner shows: <code>☁ Saving...</code> or <code>✓ Auto-saved X minutes ago</code></li>
                  <li>Auto-save is automatically cleared when you manually save a <code>.kilmer</code> file.</li>
                  <li><strong>Important:</strong> Auto-save is a safety net. Always save your work to <code>.kilmer</code> files when finished.</li>
                </ul>
              </div>

              <div className="instruction-card">
                <h4><span className="icon">⌨</span> Keyboard Shortcuts</h4>
                <div style={{ display: 'flex', justifyContent: 'flex-start', gap: '40px' }}>
                  <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                    <li style={{ marginBottom: '5px', opacity: 0.7, fontSize: '0.8em' }}>Windows / Linux</li>
                    <li><span className="key">Ctrl</span>+<span className="key">Z</span> Undo</li>
                    <li><span className="key">Ctrl</span>+<span className="key">Y</span> Redo</li>
                    <li><span className="key">Ctrl</span>+<span className="key">S</span> Save</li>
                    <li><span className="key">Ctrl</span>+<span className="key">+</span> Zoom in</li>
                    <li><span className="key">Ctrl</span>+<span className="key">−</span> Zoom out</li>
                    <li><span className="key">Ctrl</span>+<span className="key">0</span> Reset zoom</li>
                  </ul>

                  <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                    <li style={{ marginBottom: '5px', opacity: 0.7, fontSize: '0.8em' }}>macOS</li>
                    <li><span className="key">⌘</span>+<span className="key">Z</span> Undo</li>
                    <li><span className="key">⌘</span>+<span className="key">Shift</span>+<span className="key">Z</span> Redo</li>
                    <li><span className="key">⌘</span>+<span className="key">S</span> Save</li>
                    <li><span className="key">⌘</span>+<span className="key">+</span> Zoom in</li>
                    <li><span className="key">⌘</span>+<span className="key">−</span> Zoom out</li>
                    <li><span className="key">⌘</span>+<span className="key">0</span> Reset zoom</li>
                  </ul>
                </div>

                <hr style={{ margin: '15px 0', border: '0', borderTop: '1px solid #eee' }} />

                <ul className="shortcut-list" style={{ listStyle: 'none', padding: 0, margin: 0 }}>
                  <li><span className="key">Esc</span> Exit Move Mode</li>
                </ul>
              </div>
            </div>
          )}
        </div>

          <footer className="footer">
            <p>Carlos González Vergara (<strong><a href="mailto:cgonzalv@uc.cl">cgonzalv@uc.cl</a></strong>)</p>
            <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer">
              <img src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nc-nd.svg" alt="CC BY-NC-ND 4.0" />
            </a>
          </footer>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<KilmerApp />);
  </script>
</body>
</html>